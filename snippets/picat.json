{"ifthen":{"prefix":"ifel","description":"if then else control","body":"\nif ($1) then\n    $2\nelse\n    $3\nend\n$0"},"ifelif":{"prefix":"ifelif","description":"if else then control","body":"\nif ($1) then\n    $2\nelseif ($3)\n    $4\nelse\n    $5\nend\n$0"},"elif":{"prefix":"elseif","description":"elseif control","body":"\nelseif ($1)\n    $0"},"while":{"prefix":"while","description":"while loop","body":"\nwhile ($1)\n    $2\nend\n$0"},"dowhile":{"prefix":"do","description":"do-while loop","body":"\ndo\n    $2\nwhile($1)\n$0"},"foreach":{"prefix":"foreach","description":"foreach block","body":"\nforeach $1\n    $2\nend\n$0"},"basic:acyclic_term/1":{"prefix":"acyclic_term","description":"acyclic_term(Term)\n This predicate is true if Term is acyclic, meaning that Term does not contain itself.\n","body":"acyclic_term(${1:Term})$0"},"basic:and_to_list/1":{"prefix":"and_to_list","description":"and_to_list(Conj) = List\n This function converts Conj in the form(a_1 ,...,a_n ) into a list in the form [a_1 ,...,a_n ].\n","body":"and_to_list(${1:Conjunction})$0"},"basic:append/3":{"prefix":"append","description":"append(X, Y, Z)(nondet)\n This predicate is true if appending Y to X can create Z. This predicate may backtrack if X is not a complete list.^1 <#note5>* append(W, X, Y, Z)(nondet): This predicate is defined as:\n","body":"append(${1:X}, ${2:Y}, ${3:Z})$0"},"basic:append/4":{"prefix":"append","description":"append(X,Y,Z,T)","body":"append(${1:X}, ${2:Y}, ${3:Z}, ${4:T})$0"},"basic:apply/1":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S})$0"},"basic:apply/2":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S}, ${2:A1})$0"},"basic:apply/3":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S}, ${2:A1}, ${3:A2})$0"},"basic:apply/4":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S}, ${2:A1}, ${3:A2}, ${4:A3})$0"},"basic:apply/5":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4})$0"},"basic:apply/6":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5})$0"},"basic:apply/7":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6})$0"},"basic:apply/8":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7})$0"},"basic:apply/9":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7}, ${9:A8})$0"},"basic:apply/10":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7}, ${9:A8}, ${10:A9})$0"},"basic:apply/11":{"prefix":"apply","description":"apply(S, Arg_1 , ..., Arg_n ) = Val\n S is an atom or a structure. This function calls the function that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n . This function returns the value that S returns.\n","body":"apply(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7}, ${9:A8}, ${10:A9}, ${11:A10})$0"},"basic:arity/1":{"prefix":"arity","description":"arity(Struct) = Arity\n This function returns the arity of Struct, which must be a structure.\n","body":"arity(${1:Term})$0"},"basic:array/1":{"prefix":"array","description":"array(Term)\n This predicate is true if Term is an array.\n","body":"array(${1:Term})$0"},"basic:atom/1":{"prefix":"atom","description":"atom(Term)\n This predicate is true if Term is an atom.\n","body":"atom(${1:Term})$0"},"basic:atom_chars/1":{"prefix":"atom_chars","description":"atom_chars(Atm) = String\n This function returns stringthat contains the characters of the atomAtm. It throws an error if Atm is not an atom.\n","body":"atom_chars(${1:Atm})$0"},"basic:atom_codes/1":{"prefix":"atom_codes","description":"atom_codes(Atm) = List\n This function returns the listof codes of the characters of the atomAtm. It throws an error if Atm is not an atom.\n","body":"atom_codes(${1:Atm})$0"},"basic:atomic/1":{"prefix":"atomic","description":"atomic(Term)\n This predicate is true if Term is an atomor a number.\n","body":"atomic(${1:Term})$0"},"basic:attr_var/1":{"prefix":"attr_var","description":"attr_var(Term)\n This predicate is true if Term is an attributed variable.\n","body":"attr_var(${1:Term})$0"},"basic:avg/1":{"prefix":"avg","description":"avg(List) = Val\n This function returns the average of all the elements in List. This function throws an exception if List is not a list or any of the elements is not a number.\n","body":"avg(${1:ListOrArray})$0"},"basic:between/3":{"prefix":"between","description":"between(From, To, X)(nondet)\n If X is bound to an integer, then this predicate determines whether X is between From and To. Otherwise, if X is unbound, then this predicate nondeterministically selects X from the integers that are between From and To. It is the same as member(X, From..To).\n","body":"between(${1:From}, ${2:To}, ${3:X})$0"},"basic:bind_vars/2":{"prefix":"bind_vars","description":"bind_vars(Term,Val)","body":"bind_vars(${1:Term}, ${2:Val})$0"},"basic:call/1":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S})$0"},"basic:call/2":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S}, ${2:A1})$0"},"basic:call/3":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S}, ${2:A1}, ${3:A2})$0"},"basic:call/4":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S}, ${2:A1}, ${3:A2}, ${4:A3})$0"},"basic:call/5":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4})$0"},"basic:call/6":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5})$0"},"basic:call/7":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6})$0"},"basic:call/8":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7})$0"},"basic:call/9":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7}, ${9:A8})$0"},"basic:call/10":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7}, ${9:A8}, ${10:A9})$0"},"basic:call/11":{"prefix":"call","description":"call(S, Arg_1 , ..., Arg_n )\n S is an atom or a structure. This predicate calls the predicate that is named by S with the arguments that are specified in S, together with extra arguments Arg_1 , ..., Arg_n .\n","body":"call(${1:S}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7}, ${9:A8}, ${10:A9}, ${11:A10})$0"},"basic:call_cleanup/2":{"prefix":"call_cleanup","description":"call_cleanup(Call,Cleanup)\n This predicate is the same as call(Call), except that Cleanup is called when Call succeeds determinately (i.e., with no remaining choice point), when Call fails, or when Call raises an exception.\n","body":"call_cleanup(${1:S}, ${2:Cleanup})$0"},"basic:catch/3":{"prefix":"catch","description":"catch(Call, Exception, Handler)\n This predicate is the same as Call, except when an exception that matches Exception is raised during the execution of Call. When such an exception is raised, all of the bindings that have been performed on variables in Call will be undone, and Handler will be executed to handle the exception.\n","body":"catch(${1:S}, ${2:Exception}, ${3:Handler})$0"},"basic:char/1":{"prefix":"char","description":"char(Term)\n This predicate is true if Term is an atom and the atom is made of one character.\n","body":"char(${1:Term})$0"},"basic:chr/1":{"prefix":"chr","description":"chr(Code) = Char\n This function returns the UTF-8 character of the code point Code.\n","body":"chr(${1:Code})$0"},"basic:clear/1":{"prefix":"clear","description":"clear(Map)\n This predicate clears the map Map. It throws an error if Map is not a map.\n","body":"clear(${1:Map})$0"},"basic:compare_terms/2":{"prefix":"compare_terms","description":"compare_terms(Term_1 , Term_2 ) = Res\n This function compares Term_1 and Term_2 . If Term_1 < Term_2 , then this function returns ?1. If Term_1 == Term_2 , then this function returns 0. Otherwise, Term_1 > Term_2 , and this function returns 1.\n","body":"compare_terms(${1:Term1}, ${2:Term2})$0"},"basic:compound/1":{"prefix":"compound","description":"compound(Term)","body":"compound(${1:Term})$0"},"basic:copy_term/1":{"prefix":"copy_term","description":"copy_term(Term_1 ) = Term_2 \n This function copies Term_1 into Term_2 . If Term_1 is an attributed variable, then Term_2 will not contain any of the attributes.\n","body":"copy_term(${1:Term})$0"},"basic:delete/2":{"prefix":"delete","description":"delete(OSet,Elm) = OSet_1 \n This function returns of a copy of OSet that does not contain the element Elm.\n","body":"delete(${1:List}, ${2:X})$0"},"basic:delete_all/2":{"prefix":"delete_all","description":"delete_all(List, X) = ResList\n This function deletes all occurrences of X from List, returning the result in ResList. The built-in |!=/2| is used to test if two terms are different.\n","body":"delete_all(${1:List}, ${2:X})$0"},"basic:different_terms/2":{"prefix":"different_terms","description":"different_terms(Term_1 , Term_2 )\n This constraint ensures that Term_1 and Term_2 are different. This constraint is suspended when the arguments are not sufficiently instantiated.\n","body":"different_terms(${1:Term1}, ${2:Term2})$0"},"basic:digit/1":{"prefix":"digit","description":"digit(Term)\n This predicate is true if Term is an atom and the atom is made of one digit.\n","body":"digit(${1:Char})$0"},"basic:div/2":{"prefix":"div","description":"div(X,Y)","body":"div(${1:X}, ${2:Y})$0"},"basic:dvar/1":{"prefix":"dvar","description":"dvar(Term)\n This predicate is true if Term is an attributed domain variable.\n","body":"dvar(${1:Term})$0"},"basic:bool_dvar/1":{"prefix":"bool_dvar","description":"bool_dvar(Term)\n This predicate is true if Term is an attributed domain variable whose lower bound is 0 and whose upper bound is 1.\n","body":"bool_dvar(${1:Term})$0"},"basic:dvar_or_int/1":{"prefix":"dvar_or_int","description":"dvar_or_int(Term)\n This predicate is true if Term is an attributed domain variable or an integer.\n","body":"dvar_or_int(${1:Term})$0"},"basic:fail/0":{"prefix":"fail","description":"fail\n This goalis always false. When failoccurs in a condition, the condition is false, and the rule is never applicable. When failoccurs in a body, it causes execution to backtrack.\n","body":"fail"},"basic:false/0":{"prefix":"false","description":"false\n This goal is the same as fail.\n","body":"false"},"basic:find_all/2":{"prefix":"find_all","description":"find_all(Template,Call) = Answers\n This function is the same as the above function.\n","body":"find_all(${1:Template}, ${2:S})$0"},"basic:findall/2":{"prefix":"findall","description":"findall(Template,Call) = Answers\n This function returns a list of all possible instances of call(Call) that are true in the form of Template. Note that Template is assumed to be a term without function calls, and that Call is assumed to be a predicate call whose arguments can contain function calls. Also note that, like a loop, findall forms a name scope. For example, in findall(f(X),p(X,g(Y))), f(X) is a term even though it is not preceded with |$|; g(Y) is a function call; the variables X and Y are assumed to be local to findall if they do not occur before in the outer scope.\n","body":"findall(${1:Template}, ${2:S})$0"},"basic:count_all/1":{"prefix":"count_all","description":"count_all(Call) = Count\n This function returns the number of all possible instances of call(Call) that are true. For example, count_all(member(X,[1,2,3])) returns 3.\n","body":"count_all(${1:S})$0"},"basic:first/1":{"prefix":"first","description":"first(List) = Term\n This function returns the first element of List.\n","body":"first(${1:Compound})$0"},"basic:flatten/1":{"prefix":"flatten","description":"flatten(List) = ResList\n This function flattens a list of nested lists into a list. For example, flatten([[1],[2,[3]]]) returns [1,2,3].\n","body":"flatten(${1:List})$0"},"basic:float/1":{"prefix":"float","description":"float(Term)\n This predicate is true if Term is a real number.\n","body":"float(${1:Term})$0"},"basic:fold/3":{"prefix":"fold","description":"fold(F,Acc,List)","body":"fold(${1:F}, ${2:Acc}, ${3:List})$0"},"basic:freeze/2":{"prefix":"freeze","description":"freeze(X, Call)\n This predicate delays the evaluation of Call until X becomes a non-variable term.\n","body":"freeze(${1:X}, ${2:Goal})$0"},"basic:get/2":{"prefix":"get","description":"get(Map, Key) = Val\n This function returns Val of the key-value pair Key=Val in Map. It throws an error if Map does not contain the key Key.\n","body":"get(${1:Map}, ${2:Key})$0"},"basic:get/3":{"prefix":"get","description":"get(Map, Key, DefaultVal) = Val\n This function returns Val of the key-value pair Key=Val in Map. It returns DefaultVal if Map does not contain Key.\n","body":"get(${1:Map}, ${2:Key}, ${3:Default})$0"},"basic:get_attr/2":{"prefix":"get_attr","description":"get_attr(X, Key) = Val\n This function returns the Val of the key-value pair Key=Val that is attached to X. It throws an error if X has no attribute named Key.\n","body":"get_attr(${1:AttrVar}, ${2:Key})$0"},"basic:get_attr/3":{"prefix":"get_attr","description":"get_attr(X, Key, DefaultVal) = Val\n This function returns Val of the key-value pair Key=Val that is attached to X. It returns DefaultVal if X does not have the attribute named Key.\n","body":"get_attr(${1:AttrVar}, ${2:Key}, ${3:DefaultVal})$0"},"basic:get_global_map/0":{"prefix":"get_global_map","description":"get_global_map() = Map\n This function returns the global map, which is shared by all threads.\n","body":"get_global_map"},"basic:get_global_map/1":{"prefix":"get_global_map","description":"get_global_map(Id)","body":"get_global_map(${1:Id})$0"},"basic:get_heap_map/0":{"prefix":"get_heap_map","description":"get_heap_map() = Map\n This function returns the current thread's heap map. Each thread has its own heap map.\n","body":"get_heap_map"},"basic:get_heap_map/1":{"prefix":"get_heap_map","description":"get_heap_map(Id)","body":"get_heap_map(${1:Id})$0"},"basic:get_table_map/0":{"prefix":"get_table_map","description":"get_table_map() = Map\n This function returns the current thread's table map. Each thread has its own table map. The table map is stored in the table area and both keys and values are hash-consed(i.e., common sub-terms are shared).\n","body":"get_table_map"},"basic:get_table_map/1":{"prefix":"get_table_map","description":"get_table_map(Id)","body":"get_table_map(${1:Id})$0"},"basic:ground/1":{"prefix":"ground","description":"ground(Term)\n This predicate is true if Term is ground. A/ground/term does not contain any variables.\n","body":"ground(${1:Term})$0"},"basic:handle_exception/2":{"prefix":"handle_exception","description":"handle_exception(Exception,Source)","body":"handle_exception(${1:Exception}, ${2:Source})$0"},"basic:has_key/2":{"prefix":"has_key","description":"has_key(Map, Key)\n This predicate is true if Map contains a pair with Key.\n","body":"has_key(${1:Map}, ${2:Key})$0"},"basic:hash_code/1":{"prefix":"hash_code","description":"hash_code(Term) = Code\n This function returns the hash code of Term. If Term is a variable, then the returned hash code is always 0.\n","body":"hash_code(${1:Term})$0"},"basic:head/1":{"prefix":"head","description":"head(List) = Term\n This function returns the head of the list List. For example, head([1,2,3]) returns 1.\n","body":"head(${1:List})$0"},"basic:insert/3":{"prefix":"insert","description":"insert(List, Index, Elm) = ResList\n This function inserts Elm into List at the index Index, returning the result in ResList. After insertion, the original List is not changed, and ResList is the same as List.slice(1, Index-1)++[Elm|List.slice(Index, List.length)].\n","body":"insert(${1:List}, ${2:Index}, ${3:Elm})$0"},"basic:insert_all/3":{"prefix":"insert_all","description":"insert_all(List, Index, AList) = ResList\n This function inserts all of the elements in AList into List at the index Index, returning the result in ResList. After insertion, the original List is not changed, and ResList is the same as List.slice(1, Index-1)++AList++List.slice(Index, List.length).\n","body":"insert_all(${1:List}, ${2:Index}, ${3:AList})$0"},"basic:insert_ordered/2":{"prefix":"insert_ordered","description":"insert_ordered(List,Term)\n This function inserts Term into the ordered list List, such that the resulting list remains sorted.\n","body":"insert_ordered(${1:OrderedList}, ${2:Elm})$0"},"basic:insert_ordered_no_dup/2":{"prefix":"insert_ordered_no_dup","description":"insert_ordered_no_dup(OrderedList,Elm)","body":"insert_ordered_no_dup(${1:OrderedList}, ${2:Elm})$0"},"basic:insert_ordered_down/2":{"prefix":"insert_ordered_down","description":"insert_ordered_down(List,Term)\n This function inserts Term into the descendantly ordered list List, such that the resulting list remains sorted down.\n","body":"insert_ordered_down(${1:OrderedList}, ${2:Elm})$0"},"basic:insert_ordered_down_no_dup/2":{"prefix":"insert_ordered_down_no_dup","description":"insert_ordered_down_no_dup(OrderedList,Elm)","body":"insert_ordered_down_no_dup(${1:OrderedList}, ${2:Elm})$0"},"basic:int/1":{"prefix":"int","description":"int(Term)\n This predicate is true if Term is an integer.\n","body":"int(${1:Term})$0"},"basic:integer/1":{"prefix":"integer","description":"integer(Term)\n The same as int(Term).\n","body":"integer(${1:Term})$0"},"basic:is/2":{"prefix":"is","description":"is(X,Y)","body":"is(${1:X}, ${2:Y})$0"},"basic:keys/1":{"prefix":"keys","description":"keys(X) = List\n This function returns the list of keys of the pairs in Map.\n","body":"keys(${1:Map})$0"},"basic:last/1":{"prefix":"last","description":"last(List) = Term\n This function returns the last element of List.\n","body":"last(${1:Compound})$0"},"basic:length/1":{"prefix":"length","description":"length(List) = Len\n This function is the same as len(List).\n","body":"length(${1:ArrayOrList})$0"},"basic:len/1":{"prefix":"len","description":"len(List) = Len\n This function returns the number of elements in List. Note that this function is overloaded in such a way that the argument can also be an atom, an array, or a structure.\n","body":"len(${1:ArrayOrList})$0"},"basic:list/1":{"prefix":"list","description":"list(Term)\n This predicate is true if Term is a list.\n","body":"list(${1:Term})$0"},"basic:list_to_and/1":{"prefix":"list_to_and","description":"list_to_and(List) = Conj\n This function converts List in the form[a_1 ,...,a_n ] into a term in the form (a_1 ,...,a_n ).\n","body":"list_to_and(${1:List})$0"},"basic:lowercase/1":{"prefix":"lowercase","description":"lowercase(Char)","body":"lowercase(${1:Char})$0"},"basic:map/3":{"prefix":"map","description":"map(Func, List1, List2) = ResList\n Let List1 be [A_1 ,...,A_n ] and List2 be [B_1 ,...,B_n ]. This function applies the function Func to every pair of elements (A_i ,B_i ) by calling apply(Func,A_i ,B_i ), and returns a list of the results.\n","body":"map(${1:Func}, ${2:List1}, ${3:List2})$0"},"basic:map/2":{"prefix":"map","description":"map(FuncOrList, ListOrFunc) = ResList\n This function applies a function to every element of a given list and returns a list of the results. One of the arguments is a function, and the other is a list. The order of the arguments is not important.\n","body":"map(${1:FuncOrList}, ${2:ListOrFunc})$0"},"basic:map/1":{"prefix":"map","description":"map(Term)\n This predicate is true if Term is a map.\n","body":"map(${1:Term})$0"},"basic:map_to_list/1":{"prefix":"map_to_list","description":"map_to_list(Map) = PairsList\n This function returns a listof Key=Val pairs that constitute Map.\n","body":"map_to_list(${1:Map})$0"},"basic:max/1":{"prefix":"max","description":"max(DVars)\n The maximum of DVars, where DVars is a list of domain variables.\n","body":"max(${1:ListOrArray})$0"},"basic:max/2":{"prefix":"max","description":"max(Exp1, Exp2)\n The maximum of Exp1 and Exp2.\n","body":"max(${1:X}, ${2:Y})$0"},"basic:maxint_small/0":{"prefix":"maxint_small","description":"maxint_small() = Int\n This function returns the maximum integer that is represented in one word. All integers that are greater than this integer are represented as big integers.\n","body":"maxint_small()"},"basic:maxof/2":{"prefix":"maxof","description":"maxof(Call,Objective)\n This predicate finds a satisfiable instance of Call, such that Objective has the maximum value. Here, Call is used as a generator, and Objective is an expression to be maximized. For every satisfiable instance of Call, Objective must be a ground expression. For maxof, search is restarted with a new bound each time that a better answer is found.\n","body":"maxof(${1:Call}, ${2:Exp})$0"},"basic:maxof/3":{"prefix":"maxof","description":"maxof(Call,Objective,ReportCall)\n This is the same as maxof(Call,Objective), except that call(ReportCall) is executed each time that an answer is found.\n","body":"maxof(${1:Call}, ${2:Exp}, ${3:ReportCall})$0"},"basic:maxof_inc/2":{"prefix":"maxof_inc","description":"maxof_inc(Call,Objective)\n This is the same as maxof(Call,Objective), except that search continues rather than being restarted each time that a better solution is found.\n","body":"maxof_inc(${1:Call}, ${2:Exp})$0"},"basic:maxof_inc/3":{"prefix":"maxof_inc","description":"maxof_inc(Call,Objective,ReportCall)\n This is the same as the previous predicate, except that call(ReportCall) is executed each time that an answer is found.\n","body":"maxof_inc(${1:Call}, ${2:Exp}, ${3:ReportCall})$0"},"basic:membchk/2":{"prefix":"membchk","description":"membchk(Term, List)\n This predicate is true if Term is an element of List.\n","body":"membchk(${1:Term}, ${2:List})$0"},"basic:member/2":{"prefix":"member","description":"member(Term, List)(nondet)\n This predicate is true if Term is an element of List. When Term is a variable, this predicate may backtrack, instantiatingTerm to different elements of List.\n","body":"member(${1:Term}, ${2:List})$0"},"basic:min/1":{"prefix":"min","description":"min(DVars)\n The minimum of DVars, where DVars is a list of domain variables.\n","body":"min(${1:ListOrArray})$0"},"basic:min/2":{"prefix":"min","description":"min(Exp1, Exp2)\n The minimum of Exp1 and Exp2.\n","body":"min(${1:X}, ${2:Y})$0"},"basic:minint_small/0":{"prefix":"minint_small","description":"minint_small() = Int\n This function returns the minimum integer that is represented in one word. All integers that are smaller than this integer are represented as big integers.\n","body":"minint_small()"},"basic:minof/2":{"prefix":"minof","description":"minof(Call,Objective)\n This predicate finds a satisfiable instance of Call, such that Objective has the minimum value.\n","body":"minof(${1:Call}, ${2:Exp})$0"},"basic:minof/3":{"prefix":"minof","description":"minof(Call,Objective,ReportCall)\n This is the same as minof(Call,Objective), except that call(ReportCall) is executed each time that an answer is found.\n","body":"minof(${1:Call}, ${2:Exp}, ${3:ReportCall})$0"},"basic:minof_inc/2":{"prefix":"minof_inc","description":"minof_inc(Call,Objective)\n This predicate is the same as minof(Call,Objective), except that search continues rather than being restarted each time that a better solution is found.\n","body":"minof_inc(${1:Call}, ${2:Exp})$0"},"basic:minof_inc/3":{"prefix":"minof_inc","description":"minof_inc(Call,Objective,ReportCall)\n This predicate is the same as the previous one, except that call(ReportCall) is executed each time that an answer is found.\n","body":"minof_inc(${1:Call}, ${2:Exp}, ${3:ReportCall})$0"},"basic:mod/2":{"prefix":"mod","description":"mod(X,Y)","body":"mod(${1:X}, ${2:Y})$0"},"basic:name/1":{"prefix":"name","description":"name(Struct)","body":"name(${1:Struct})$0"},"basic:new_array/1":{"prefix":"new_array","description":"new_array(D_1 , ..., D_n ) = Arr\n This function creates an n-dimensional array, where each D_i is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10. \n","body":"new_array(${1:D1})$0"},"basic:new_array/2":{"prefix":"new_array","description":"new_array(D_1 , ..., D_n ) = Arr\n This function creates an n-dimensional array, where each D_i is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10. \n","body":"new_array(${1:D1}, ${2:D2})$0"},"basic:new_array/3":{"prefix":"new_array","description":"new_array(D_1 , ..., D_n ) = Arr\n This function creates an n-dimensional array, where each D_i is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10. \n","body":"new_array(${1:D1}, ${2:D2}, ${3:D3})$0"},"basic:new_array/4":{"prefix":"new_array","description":"new_array(D_1 , ..., D_n ) = Arr\n This function creates an n-dimensional array, where each D_i is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10. \n","body":"new_array(${1:D1}, ${2:D2}, ${3:D3}, ${4:D4})$0"},"basic:new_array/5":{"prefix":"new_array","description":"new_array(D_1 , ..., D_n ) = Arr\n This function creates an n-dimensional array, where each D_i is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10. \n","body":"new_array(${1:D1}, ${2:D2}, ${3:D3}, ${4:D4}, ${5:D5})$0"},"basic:new_array/6":{"prefix":"new_array","description":"new_array(D_1 , ..., D_n ) = Arr\n This function creates an n-dimensional array, where each D_i is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10. \n","body":"new_array(${1:D1}, ${2:D2}, ${3:D3}, ${4:D4}, ${5:D5}, ${6:D6})$0"},"basic:new_array/7":{"prefix":"new_array","description":"new_array(D_1 , ..., D_n ) = Arr\n This function creates an n-dimensional array, where each D_i is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10. \n","body":"new_array(${1:D1}, ${2:D2}, ${3:D3}, ${4:D4}, ${5:D5}, ${6:D6}, ${7:D7})$0"},"basic:new_array/8":{"prefix":"new_array","description":"new_array(D_1 , ..., D_n ) = Arr\n This function creates an n-dimensional array, where each D_i is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10. \n","body":"new_array(${1:D1}, ${2:D2}, ${3:D3}, ${4:D4}, ${5:D5}, ${6:D6}, ${7:D7}, ${8:D8})$0"},"basic:new_array/9":{"prefix":"new_array","description":"new_array(D_1 , ..., D_n ) = Arr\n This function creates an n-dimensional array, where each D_i is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10. \n","body":"new_array(${1:D1}, ${2:D2}, ${3:D3}, ${4:D4}, ${5:D5}, ${6:D6}, ${7:D7}, ${8:D8}, ${9:D9})$0"},"basic:new_array/10":{"prefix":"new_array","description":"new_array(D_1 , ..., D_n ) = Arr\n This function creates an n-dimensional array, where each D_i is an integer expression that specifies the size of a dimension. In the current implementation, n cannot exceed 10. \n","body":"new_array(${1:D1}, ${2:D2}, ${3:D3}, ${4:D4}, ${5:D5}, ${6:D6}, ${7:D7}, ${8:D8}, ${9:D9}, ${10:D10})$0"},"basic:new_list/1":{"prefix":"new_list","description":"new_list(N) = List\n This function creates a new list that has N free variablearguments.\n","body":"new_list(${1:N})$0"},"basic:new_list/2":{"prefix":"new_list","description":"new_list(N,InitVal) = List\n This function creates a new list that has N arguments all initialized to InitVal.\n","body":"new_list(${1:N}, ${2:InitVal})$0"},"basic:new_map/0":{"prefix":"new_map","description":"new_map()","body":"new_map()"},"basic:new_map/2":{"prefix":"new_map","description":"new_map(N,PairsList) = Map\n This function creates a mapwith the initial capacity N, the initial list of pairs PairsList, where each pair has the form Key=Val.\n","body":"new_map(${1:Int}, ${2:PairsList})$0"},"basic:new_map/1":{"prefix":"new_map","description":"new_map(IntOrPairsList) = Map\n This function creates a mapwith an initial capacity or an initial list of pairs.\n","body":"new_map(${1:IntOrPairsList})$0"},"basic:new_set/0":{"prefix":"new_set","description":"new_set()","body":"new_set()"},"basic:new_set/2":{"prefix":"new_set","description":"new_set(N,KeysList) = Set\n This function creates a set with the initial capacity N and the initial list of keys KeysList. \n","body":"new_set(${1:Int}, ${2:PairsList})$0"},"basic:new_set/1":{"prefix":"new_set","description":"new_set(IntOrKeysList) = Set\n This function creates a set with an initial capacity or an initial list of keys.\n","body":"new_set(${1:IntOrPairsList})$0"},"basic:new_struct/2":{"prefix":"new_struct","description":"new_struct(Name, IntOrList) = Struct\n This function creates a structurethat has the name Name. If IntOrList is an integer, N, then the structurehas N free variablearguments. Otherwise, if IntOrList is a list, then the structurecontains the elements in the list.\n","body":"new_struct(${1:Name}, ${2:IntOrList})$0"},"basic:nonvar/1":{"prefix":"nonvar","description":"nonvar(Term)\n This predicate is true if Term is not a free variable. \n","body":"nonvar(${1:Term})$0"},"basic:not/1":{"prefix":"not","description":"not(Call)","body":"not(${1:Call})$0"},"basic:nth/3":{"prefix":"nth","description":"nth(Index, List, Elem)(nondet)\n This predicate is true when Elem is the Index'th element of List. Counting starts at 1. When Index is a variable, this predicate may backtrack, instantiating Index to a different integer between 1 and len(List).\n","body":"nth(${1:I}, ${2:L}, ${3:V})$0"},"basic:number/1":{"prefix":"number","description":"number(Term)\n This predicate is true if Term is a number.\n","body":"number(${1:Term})$0"},"basic:number_chars/1":{"prefix":"number_chars","description":"number_chars(Num) = String\n This function returns a listof characters of Num. This function is the same as to_fstring(\"%d\",Num)if Num is an integer, and the same as to_fstring(\"%f\",Num)if Num is a real number.\n","body":"number_chars(${1:Num})$0"},"basic:number_codes/1":{"prefix":"number_codes","description":"number_codes(Num) = List\n This function returns a listof codes of the characters of Num. It is the same as number_chars(Num).to_codes().\n","body":"number_codes(${1:Num})$0"},"basic:number_vars/2":{"prefix":"number_vars","description":"number_vars(Term, N_0 ) = N_1 \n This function numbers the variables in Term by using the integers starting from N_0 . N_1 is the next integer that is available after Term is numbered. Different variables receive different numberings, and the occurrences of the same variable all receive the same numbering.\n","body":"number_vars(${1:Term}, ${2:N0})$0"},"basic:once/1":{"prefix":"once","description":"once(Call)","body":"once(${1:Call})$0"},"basic:ord/1":{"prefix":"ord","description":"ord(Char) = Int\n This function returns the code point of the UTF-8 character Char. It throws an error if Char is not a single-character atom. \n","body":"ord(${1:Char})$0"},"basic:parse_radix_string/2":{"prefix":"parse_radix_string","description":"parse_radix_string(String, Base) = Int\n This function converts a radix String of Base into a decimal integer Int, where Base must be greater than 1 and less than 37. For example, parse_radix_string(\"101\",2) returns 5, which is the same as parse_term(\"0b101\").\n","body":"parse_radix_string(${1:String}, ${2:Base})$0"},"basic:parse_term/1":{"prefix":"parse_term","description":"parse_term(String) = Term\n This function converts String to a term.\n","body":"parse_term(${1:String})$0"},"basic:parse_term/3":{"prefix":"parse_term","description":"parse_term(String, Term, Vars)\n This predicate uses the Picat parser to extract a term Term from String. Vars is a list of pairs, where each pair has the form Name=Var.\n","body":"parse_term(${1:String}, ${2:Term}, ${3:Vars})$0"},"basic:post_event/2":{"prefix":"post_event","description":"post_event(X,Event)","body":"post_event(${1:X}, ${2:Event})$0"},"basic:post_event_any/2":{"prefix":"post_event_any","description":"post_event_any(X, T)\n posts the event T to the any-portof the channel of X. \n","body":"post_event_any(${1:X}, ${2:Event})$0"},"basic:post_event_bound/1":{"prefix":"post_event_bound","description":"post_event_bound(X)\n posts an event to the bound-portof the channel X.\n","body":"post_event_bound(${1:X})$0"},"basic:post_event_dom/2":{"prefix":"post_event_dom","description":"post_event_dom(X, T)\n posts the term T to the dom-portof the channel X.\n","body":"post_event_dom(${1:X}, ${2:Event})$0"},"basic:post_event_ins/1":{"prefix":"post_event_ins","description":"post_event_ins(X)\n posts an event to the ins-portof the channel X.\n","body":"post_event_ins(${1:X})$0"},"basic:prod/1":{"prefix":"prod","description":"prod(DVars)\n The product of DVars, where DVars is a list of domain variables. \n","body":"prod(${1:ListOrArray})$0"},"basic:put/3":{"prefix":"put","description":"put(Map, Key, Val)\n This predicate attaches the key-value pair Key=Val to Map, where Key is a non-variable term, and Val is any term.\n","body":"put(${1:Map}, ${2:Key}, ${3:Val})$0"},"basic:put/2":{"prefix":"put","description":"put(Map, Key)\n This predicate is the same as put(Map, Key, not_a_value).\n","body":"put(${1:Map}, ${2:Key})$0"},"basic:put_attr/3":{"prefix":"put_attr","description":"put_attr(X, Key, Val)\n This predicate attaches the key-value pair Key=Val to X, where Key is a non-variable term, and Val is any term.\n","body":"put_attr(${1:AttrVar}, ${2:Key}, ${3:Val})$0"},"basic:real/1":{"prefix":"real","description":"real(Term)\n This predicate is the same as float(Term).\n","body":"real(${1:Term})$0"},"basic:reduce/2":{"prefix":"reduce","description":"reduce(Func,List) = Res\n If List contains only one element, this function returns the element. If List contains at least two elements, then the first two elements A_1 and A_2 are replaced with apply(Func,A_1 ,A_2 ). This step is repeatedly applied to the list until the list contains a single element, which is the final value to be returned.\n","body":"reduce(${1:ListOrF}, ${2:FOrList})$0"},"basic:reduce/3":{"prefix":"reduce","description":"reduce(Func,List,InitVal) = Res\n This function is the same as reduce(Func,[InitVal|List]). \n","body":"reduce(${1:ListOrF}, ${2:FOrList}, ${3:InitVal})$0"},"basic:rem/2":{"prefix":"rem","description":"rem(X,Y)","body":"rem(${1:X}, ${2:Y})$0"},"basic:remove_dups/1":{"prefix":"remove_dups","description":"remove_dups(List) = ResList\n This function removes all duplicate values from List, retaining only the first occurrence of each value. The result is returned in ResList. Note that an O(n^2 ) algorithm is used in the implementation. If List is large, then sort_remove_dups(List) may be faster than this function.\n","body":"remove_dups(${1:List})$0"},"basic:repeat/0":{"prefix":"repeat","description":"repeat\n This predicate is defined as follows: repeat ?=> true. repeat => repeat.\n","body":"repeat"},"basic:reverse/1":{"prefix":"reverse","description":"reverse(List) = ResList\n This function reverses the order of the elements in List, returning the result in ResList.\n","body":"reverse(${1:ListOrArray})$0"},"basic:second/1":{"prefix":"second","description":"second(Compound) = Term\n This function returns the second argument of the compound term Compound.\n","body":"second(${1:Compound})$0"},"basic:select/3":{"prefix":"select","description":"select(X, List, ResList)(nondet)\n This predicate nondeterministically selects an element X from List, and binds ResList to the list after X is removed. On backtracking, it selects the next element.\n","body":"select(${1:X}, ${2:List}, ${3:ResList})$0"},"basic:size/1":{"prefix":"size","description":"size(Map) = Size\n This function returns the number of pairs in Map. \n","body":"size(${1:Map})$0"},"basic:slice/2":{"prefix":"slice","description":"slice(List,From) = SList\n This function is the same as the following. slice(List,From,List.length)\n","body":"slice(${1:ListOrArray}, ${2:From})$0"},"basic:slice/3":{"prefix":"slice","description":"slice(List,From,To) = SList\n This function returns the sliced list of List from index From through index To. From must not be less than 1.\n","body":"slice(${1:ListOrArray}, ${2:From}, ${3:To})$0"},"basic:sort/1":{"prefix":"sort","description":"sort(List) = SList\n This function sorts the elements of List in ascending order, returning the result in SList.\n","body":"sort(${1:ListOrArray})$0"},"basic:sort/2":{"prefix":"sort","description":"sort(List,KeyIndex) = SList\n This function sorts the elements of List by the key index KeyIndex in ascending order, returning the result in SList. The elements of List must be compound values and KeyIndex must be a positive integer that does not exceed the length of any of the elements of List. This function is defined as follows:\n","body":"sort(${1:ListOrArray}, ${2:KeyIndex})$0"},"basic:sort_down/1":{"prefix":"sort_down","description":"sort_down(List) = SList\n This function sorts the elements of List in descending order, returning the result in SList.\n","body":"sort_down(${1:ListOrArray})$0"},"basic:sort_down/2":{"prefix":"sort_down","description":"sort_down(List,KeyIndex) = SList\n This function sorts the elements of List by the key index KeyIndex in descending order, returning the result in SList.\n","body":"sort_down(${1:ListOrArray}, ${2:KeyIndex})$0"},"basic:sort_down_remove_dups/1":{"prefix":"sort_down_remove_dups","description":"sort_down_remove_dups(List) = SList\n This function is the same as the following, but is faster. sort_down(List).remove_dups()\n","body":"sort_down_remove_dups(${1:ListOrArray})$0"},"basic:sort_down_remove_dups/2":{"prefix":"sort_down_remove_dups","description":"sort_down_remove_dups(List,KeyIndex) = SList\n This function is the same as the following, but is faster. sort_down(List,KeyIndex).remove_dups()\n","body":"sort_down_remove_dups(${1:ListOrArray}, ${2:KeyIndex})$0"},"basic:sort_remove_dups/1":{"prefix":"sort_remove_dups","description":"sort_remove_dups(List) = SList\n This function is the same as the following, but is faster. sort(List).remove_dups()\n","body":"sort_remove_dups(${1:ListOrArray})$0"},"basic:sort_remove_dups/2":{"prefix":"sort_remove_dups","description":"sort_remove_dups(List,KeyIndex) = SList\n This function is the same as the following, but is faster. sort(List,KeyIndex).remove_dups()\n","body":"sort_remove_dups(${1:ListOrArray}, ${2:KeyIndex})$0"},"basic:sorted/1":{"prefix":"sorted","description":"sorted(ListOrArray)","body":"sorted(${1:ListOrArray})$0"},"basic:sorted_down/1":{"prefix":"sorted_down","description":"sorted_down(ListOrArray)","body":"sorted_down(${1:ListOrArray})$0"},"basic:string/1":{"prefix":"string","description":"string(Term)\n This predicate is true if Term is a string.\n","body":"string(${1:Term})$0"},"basic:struct/1":{"prefix":"struct","description":"struct(Term)\n This predicate is true if Term is a structure.\n","body":"struct(${1:Term})$0"},"basic:subsumes/2":{"prefix":"subsumes","description":"subsumes(Term_1 , Term_2 )\n This predicate is true if Term_1 subsumes Term_2 .\n","body":"subsumes(${1:Term1}, ${2:Term2})$0"},"basic:sum/1":{"prefix":"sum","description":"sum(DVars)\n The sum of DVars, where DVars is a list of domain variables.\n","body":"sum(${1:ListOrArray})$0"},"basic:tail/1":{"prefix":"tail","description":"tail(List) = Term\n This function returns the tail of the list List. For example, the call tail([1,2,3]) returns [2,3].\n","body":"tail(${1:List})$0"},"basic:throw/1":{"prefix":"throw","description":"throw(E)","body":"throw(${1:E})$0"},"basic:to_array/1":{"prefix":"to_array","description":"to_array(List) = Array\n This function converts the listList to an array. The elements of the arrayare in the same order as the elements of the list.\n","body":"to_array(${1:List})$0"},"basic:to_atom/1":{"prefix":"to_atom","description":"to_atom(String)","body":"to_atom(${1:String})$0"},"basic:to_binary_string/1":{"prefix":"to_binary_string","description":"to_binary_string(Int) = String\n This function returns the binary representation of the integerInt as a string.\n","body":"to_binary_string(${1:Int})$0"},"basic:to_codes/1":{"prefix":"to_codes","description":"to_codes(Term) = Codes\n This function returns a list of character codes of Term.\n","body":"to_codes(${1:Term})$0"},"basic:to_fstring/1":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Term})$0"},"basic:to_fstring/2":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Format}, ${2:A1})$0"},"basic:to_fstring/3":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Format}, ${2:A1}, ${3:A2})$0"},"basic:to_fstring/4":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Format}, ${2:A1}, ${3:A2}, ${4:A3})$0"},"basic:to_fstring/5":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Format}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4})$0"},"basic:to_fstring/6":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Format}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5})$0"},"basic:to_fstring/7":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Format}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6})$0"},"basic:to_fstring/8":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Format}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7})$0"},"basic:to_fstring/9":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Format}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7}, ${9:A8})$0"},"basic:to_fstring/10":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Format}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7}, ${9:A8}, ${10:A9})$0"},"basic:to_fstring/11":{"prefix":"to_fstring","description":"to_fstring(Format, Args...)\n This function converts the arguments in the Args... parameter into a string, according to the format string Format, and returns the string. The number of arguments in Args... cannot exceed 10. Format characters are described in Chapter 10<#chapter%3Aio>.\n","body":"to_fstring(${1:Format}, ${2:A1}, ${3:A2}, ${4:A3}, ${5:A4}, ${6:A5}, ${7:A6}, ${8:A7}, ${9:A8}, ${10:A9}, ${11:A10})$0"},"basic:to_hex_string/1":{"prefix":"to_hex_string","description":"to_hex_string(Int) = String\n This function returns the hexadecimal representation of the integerInt as a string.\n","body":"to_hex_string(${1:Int})$0"},"basic:to_integer/1":{"prefix":"to_integer","description":"to_integer(ANS) = Int\n This function is the same as to_int(ANS).\n","body":"to_integer(${1:NumOrCharOrString})$0"},"basic:to_int/1":{"prefix":"to_int","description":"to_int(ANS) = Int\n This function is the same as truncate(ANS)in the math module if ANS is a number, the same as ord(ANS)-ord('0') if ANS is a digit character, and the same as parse_term(ANS) if ANS is a string.\n","body":"to_int(${1:NumOrCharOrString})$0"},"basic:to_list/1":{"prefix":"to_list","description":"to_list(Struct) = List\n This function returns a listof the components of the structureStruct. \n","body":"to_list(${1:Struct})$0"},"basic:to_lowercase/1":{"prefix":"to_lowercase","description":"to_lowercase(String) = LString\n This function converts all uppercase alphabetic characters into lowercase characters, returning the result in LString.\n","body":"to_lowercase(${1:StringOrChar})$0"},"basic:to_number/1":{"prefix":"to_number","description":"to_number(ANS) = Num\n This function is the same as ANS if ANS is a number, the same as ord(ANS)-ord('0') if ANS is a digit character, and the same as parse_term(ANS) if ANS is a string.\n","body":"to_number(${1:NumOrCharOrString})$0"},"basic:to_oct_string/1":{"prefix":"to_oct_string","description":"to_oct_string(Int) = String\n This function returns the octal representation of the integer Int as a string.\n","body":"to_oct_string(${1:Int})$0"},"basic:to_radix_string/2":{"prefix":"to_radix_string","description":"to_radix_string(Int,Base) = String\n This function returns the representation of the integer Int of the numeral Base as a string, where Base must be greater than 1 and less than 37. The call to_oct_string(Int) is the same as to_radix_string(Int,8).\n","body":"to_radix_string(${1:Int}, ${2:Base})$0"},"basic:to_real/1":{"prefix":"to_real","description":"to_real(NS) = Real\n This function is the same as to_float(NS). \n","body":"to_real(${1:NumOrString})$0"},"basic:to_float/1":{"prefix":"to_float","description":"to_float(NS) = Real\n This function is the same as NS*1.0 if NS is a number, and the same as parse_term(NS) if NS is a string of digits.\n","body":"to_float(${1:NumOrString})$0"},"basic:to_string/1":{"prefix":"to_string","description":"to_string(Term) = String\n This function returns a string representation of Term. \n","body":"to_string(${1:Term})$0"},"basic:to_uppercase/1":{"prefix":"to_uppercase","description":"to_uppercase(String) = UString\n This function converts all lowercase alphabetic characters into uppercase characters, returning the result in UString. \n","body":"to_uppercase(${1:StringOrChar})$0"},"basic:true/0":{"prefix":"true","description":"true\n This goalis always true.\n","body":"true"},"basic:uppercase/1":{"prefix":"uppercase","description":"uppercase(Char)","body":"uppercase(${1:Char})$0"},"basic:values/1":{"prefix":"values","description":"values(Map) = List\n This function returns the listof values of the pairs in Map.\n","body":"values(${1:Map})$0"},"basic:var/1":{"prefix":"var","description":"var(Term)\n This predicate is true if Term is a free variable.\n","body":"var(${1:Term})$0"},"basic:variant/2":{"prefix":"variant","description":"variant(Term_1 , Term_2 )\n This predicate is true if Term_2 is a variant of Term_1 .\n","body":"variant(${1:Term1}, ${2:Term2})$0"},"basic:vars/1":{"prefix":"vars","description":"vars(Term) = Vars\n This function returns a listof variables that occur in Term. \n","body":"vars(${1:Term})$0"},"basic:zip/1":{"prefix":"zip","description":"zip(List_1 , List_2 , ..., List_n ) = List\n This function makes a listof array tuples. The jth tuple in the list takes the form {E_1j,...,E_nj }, where E_ij is the jth element in List_i . In the current implementation, n can be 2, 3, or 4.\n","body":"zip(${1:Lists})$0"},"basic:zip/2":{"prefix":"zip","description":"zip(List_1 , List_2 , ..., List_n ) = List\n This function makes a listof array tuples. The jth tuple in the list takes the form {E_1j,...,E_nj }, where E_ij is the jth element in List_i . In the current implementation, n can be 2, 3, or 4.\n","body":"zip(${1:List1}, ${2:List2})$0"},"basic:zip/3":{"prefix":"zip","description":"zip(List_1 , List_2 , ..., List_n ) = List\n This function makes a listof array tuples. The jth tuple in the list takes the form {E_1j,...,E_nj }, where E_ij is the jth element in List_i . In the current implementation, n can be 2, 3, or 4.\n","body":"zip(${1:List1}, ${2:List2}, ${3:List3})$0"},"basic:zip/4":{"prefix":"zip","description":"zip(List_1 , List_2 , ..., List_n ) = List\n This function makes a listof array tuples. The jth tuple in the list takes the form {E_1j,...,E_nj }, where E_ij is the jth element in List_i . In the current implementation, n can be 2, 3, or 4.\n","body":"zip(${1:List1}, ${2:List2}, ${3:List3}, ${4:List4})$0"},"cp:solve/1":{"prefix":"solve","description":"solve(Vars)\n This predicate is the same as solve([], Vars).\n","body":"solve(${1:Vars})$0"},"cp:solve/2":{"prefix":"solve","description":"solve(Options, Vars)\n This predicate calls the imported solver to label the variables Vars with values, where Options is a list of options for the solver. The options will be detailed below. For cp and sat, this predicate can backtrack in order to find multiple solutions. However, for mip, this call cannot backtrack. The cp module allows incremental labeling of variables, and some variables that occur in constraints but are not passed to solve may remain uninstantiated after a call to solve. The user is responsible for having all the variables that need to be instantiated passed to solve. In constrast, the sat module does not support incremental labeling of variables; once a call to solve succeeds, all the variables in constraints, whether they are passed to solve or not, will be instantiated when solve succeeds.\n","body":"solve(${1:Options}, ${2:Vars})$0"},"cp:solve_all/1":{"prefix":"solve_all","description":"solve_all(Vars)","body":"solve_all(${1:Vars})$0"},"cp:solve_all/2":{"prefix":"solve_all","description":"solve_all(Options, Vars) = Solutions\n This function returns all the solutions that satisfy the constraints.^2 <#note10>* solve_all(Vars) = Solutions: This function is the same as solve_all([],Vars).\n","body":"solve_all(${1:Options}, ${2:Vars})$0"},"cp:solve_suspended/0":{"prefix":"solve_suspended","description":"solve_suspended\n This predicate is the same as solve_suspended([]).\n","body":"solve_suspended"},"cp:solve_suspended/1":{"prefix":"solve_suspended","description":"solve_suspended(Options)\n After solve(Vars) has successfully labeled Vars, some constraints may remain suspended and not completely checked because not all of the decision variables are included in Vars. The solve_suspended(Options) predicate labels all remaining variables in the suspended constraints. This predicate is only provided by the cp module.\n","body":"solve_suspended(${1:Options})$0"},"cp:all_different/1":{"prefix":"all_different","description":"all_different(FDVars)\n This constraint ensures that each pair of variables in the list or array FDVars is different. This constraint is compiled into a set of inequality constraints. For each pair of variables V1 and V2 in FDVars, all_different(FDVars)generates the constraint V1|#!=|V2.\n","body":"all_different(${1:FDVars})$0"},"cp:all_distinct/1":{"prefix":"all_distinct","description":"all_distinct(FDVars)\n This constraint is the same as all_different, but it maintains a higher level of consistency. For some problems, this constraint is faster and requires fewer backtracks than all_different, and, for some other problems, this constraint is slower due to the overhead of consistency checking.\n","body":"all_distinct(${1:FDVars})$0"},"cp:assignment/2":{"prefix":"assignment","description":"assignment(FDVars1, FDVars2)\n This constraint ensures that FDVars2 is a /dual assignment/ of FDVars1, i.e., if the ith element of FDVars1 is j, then the jth element of FDVars2 is i. The constraint can be defined as:\n","body":"assignment(${1:FDVars1}, ${2:FDVars2})$0"},"cp:circuit/1":{"prefix":"circuit","description":"circuit(FDVars)\n Let FDVars be a list of variables [X_1 ,X_2 ,...,X_N], where each X_i has the domain 1..N. A valuation X_1 =v_1 , X_2=v_2 , ..., X_n =v_n satisfies the constraint if 1->v_1 , 2->v_2 ,..., n->v_n forms a Hamiltonian cycle. This constraint ensures that each variable has a different value, and that the graph that is formed by the assignment does not contain any sub-cycles. For example, for the constraint\n","body":"circuit(${1:FDVars})$0"},"cp:count/4":{"prefix":"count","description":"count(V, FDVars, Rel, N)\n In this constraint, V and N are integer-domain variables, FDVars is a list of integer-domain variables, and Rel is an arithmetic constraint operator (|#=|,|#!=|, |#>|, |#>=|, |#<|, |#=<|, or |#<=|). Let Count be the number of elements in FDVars that are equal to V. The constraint is true iff Count Rel N is true. This constraint can be defined as follows:\n","body":"count(${1:V}, ${2:FDVars}, ${3:Rel}, ${4:N})$0"},"cp:count/3":{"prefix":"count","description":"count(V,FDVars,N)","body":"count(${1:V}, ${2:FDVars}, ${3:N})$0"},"cp:cumulative/4":{"prefix":"cumulative","description":"cumulative(Starts, Durations, Resources, Limit)\n This constraint is useful for describing and solving scheduling problems. The arguments Starts, Durations, and Resources are lists of integer-domain variables of the same length, and Limit is an integer-domain variable. Let Starts be [S_1 , S_2 , ..., S_n ], Durations be [D_1 , D_2 , ..., D_n ], and Resources be [R_1 , R_2 , ..., R_n ]. For each job i, S_i represents the start time, D_i represents the duration, and R_i represents the units of resources needed. Limit is the limit on the units of resources available at any time. This constraint ensures that the limit cannot be exceeded at any time.\n","body":"cumulative(${1:Starts}, ${2:Durations}, ${3:Resources}, ${4:Limit})$0"},"cp:diffn/1":{"prefix":"diffn","description":"diffn(RectangleList)\n This constraint ensures that no two rectangles in RectangleList overlap with each other. A rectangle in an n-dimensional space is represented by a list of 2 n elements [X_1 , X_2 , ..., X_n , S_1 , S_2 , ..., S_n ], where X_i is the starting coordinate of the edge in the ith dimension, and S_i is the size of the edge.\n","body":"diffn(${1:RectangleList})$0"},"cp:disjunctive_tasks/1":{"prefix":"disjunctive_tasks","description":"disjunctive_tasks(Tasks)\n Tasks is a list of terms. Each term has the form disj_tasks(S_1 ,D_1 ,S_2 ,D_2 ), where S_1 and S_2 are two integer-domain variables, and D_1 and D_2 are two positive integers. This constraint is equivalent to posting the disjunctive constraint S_1 +D_1 |#=<| S_2 |#\\/| S_2 +D_2 |#=<| S_1 for each term disj_tasks(S_1 ,D_1 ,S_2 ,D_2 ) in Tasks; however the constraint may be more efficient, because it converts the disjunctive tasks into global constraints. This constraint is only accepted by cp.\n","body":"disjunctive_tasks(${1:Tasks})$0"},"cp:element/3":{"prefix":"element","description":"element(I, List, V)\n This constraint is true if the Ith element of List is V, where I and V are integer-domain variables, and List is a list of integer-domain variables.\n","body":"element(${1:I}, ${2:Terms}, ${3:V})$0"},"cp:fd_degree/1":{"prefix":"fd_degree","description":"fd_degree(FDVar) = Degree\n This function returns the number of propagators that are attached to FDVar. This built-in is only provided by cp.\n","body":"fd_degree(${1:FDVar})$0"},"cp:fd_disjoint/2":{"prefix":"fd_disjoint","description":"fd_disjoint(FDVar1, FDVar2)\n This predicate is true if FDVar1's domain and FDVar2's domain are disjoint.\n","body":"fd_disjoint(${1:DVar1}, ${2:DVar2})$0"},"cp:fd_set_false/2":{"prefix":"fd_set_false","description":"fd_set_false(FDVar, Elm)\n This predicate excludes the element Elm from the domain of FDVar. If this operation results in a hole in the domain, then the domain changes from an interval representation into a bit-vector representation, no matter how big the domain is. This built-in is only provided by cp.\n","body":"fd_set_false(${1:FDVar}, ${2:Elm})$0"},"cp:global_cardinality/2":{"prefix":"global_cardinality","description":"global_cardinality(List, Pairs)\n Let List be a list of integer-domain variables [X_1 , ..., X_d ], and Pairs be a list of pairs [K_1 -V_1 , ..., K_n -V_n ], where each key K_i is a unique integer, and each V_i is an integer-domain variable. The constraint is true if every element of List is equal to some key, and, for each pair K_i -V_i , exactly V_i elements of List are equal to K_i . This constraint can be defined as follows:\n","body":"global_cardinality(${1:List}, ${2:Pairs})$0"},"cp:indomain/1":{"prefix":"indomain","description":"indomain(Var)\n This predicate is only accepted by cp. It is the same as solve([], [Var]).\n","body":"indomain(${1:Var})$0"},"cp:indomain_down/1":{"prefix":"indomain_down","description":"indomain_down(Var)\n This predicate is the same as solve([down],[Var]). It is only accepted by cp. \n","body":"indomain_down(${1:Var})$0"},"cp:neqs/1":{"prefix":"neqs","description":"neqs(NeqList)\n NeqList is a list of inequality constraints of the form X |#!=| Y, where X and Y are integer-domain variables. This constraint is equivalent to the conjunction of the inequality constraints in NeqList, but it extracts all_distinctconstraints from the inequality constraints. This constraint is only accepted by cp.\n","body":"neqs(${1:Neqs})$0"},"cp:serialized/2":{"prefix":"serialized","description":"serialized(Starts, Durations)\n This constraint describes a set of non-overlapping tasks, where Starts and Durations are lists of integer-domain variables, and the lists have the same length. Let Os be a list of 1s that has the same length as Starts. This constraint is equivalent to cumulative(Starts,Durations,Os,1).\n","body":"serialized(${1:Starts}, ${2:Durations})$0"},"cp:subcircuit/1":{"prefix":"subcircuit","description":"subcircuit(FDVars)\n This constraint is the same as circuit(FDVars), except that not all of the vertices are required to be in the circuit. If the ith element of FDVars is i, then the vertex i is not part of the circuit. This constraint is only accepted by cp and sat.\n","body":"subcircuit(${1:FDVars})$0"},"cp:new_fd_var/0":{"prefix":"new_fd_var","description":"new_fd_var() = FDVar","body":"new_fd_var() = FDVar"},"cp:new_dvar/0":{"prefix":"new_dvar","description":"new_dvar() = FDVar\n This function creates a new domain variable with the default domain, which has the bounds-72057594037927935..72057594037927935 on 64-bit computers and-268435455..268435455 on 32-bit computers. \n","body":"new_dvar() = FDVar"},"cp:table_in/2":{"prefix":"table_in","description":"table_in(Vars,Tuples)","body":"table_in(${1:Vars}, ${2:Tuples})$0"},"cp:notin/2":{"prefix":"notin","description":"notin(Vars,Domain)","body":"notin(${1:Vars}, ${2:Domain})$0"},"cp:table_notin/2":{"prefix":"table_notin","description":"table_notin(Vars,Tuples)","body":"table_notin(${1:Vars}, ${2:Tuples})$0"},"cp:fd_dom/1":{"prefix":"fd_dom","description":"fd_dom(FDVar) = List\n This function returns the domain of FDVar as a list, where FDVar is an integer-domain variable. If FDVar is an integer, then the returned list contains the integer itself.\n","body":"fd_dom(${1:FDVar})$0"},"cp:fd_false/2":{"prefix":"fd_false","description":"fd_false(FDVar, Elm)\n This predicate is true if the integer Elm is not an element in the domain of FDVar.\n","body":"fd_false(${1:FDVar}, ${2:Elm})$0"},"cp:fd_max/1":{"prefix":"fd_max","description":"fd_max(FDVar) = Max\n This function returns the upper bound of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_max(${1:FDVar})$0"},"cp:fd_min/1":{"prefix":"fd_min","description":"fd_min(FDVar) = Min\n This function returns the lower bound of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_min(${1:FDVar})$0"},"cp:fd_min_max/3":{"prefix":"fd_min_max","description":"fd_min_max(FDVar, Min, Max)\n This predicate binds Min to the lower bound of the domain of FDVar, and binds Max to the upper bound of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_min_max(${1:FDVar}, ${2:Min}, ${3:Max})$0"},"cp:fd_next/2":{"prefix":"fd_next","description":"fd_next(FDVar, Elm) = NextElm\n This function returns the next element of Elm in FDVar's domain. It throws an exception if Elm has no next element in FDVar's domain.\n","body":"fd_next(${1:FDVar}, ${2:Elm})$0"},"cp:fd_prev/2":{"prefix":"fd_prev","description":"fd_prev(FDVar, Elm) = PrevElm\n This function returns the previous element of Elm in FDVar's domain. It throws an exception if Elm has no previous element in FDVar's domain.\n","body":"fd_prev(${1:FDVar}, ${2:Elm})$0"},"cp:fd_size/1":{"prefix":"fd_size","description":"fd_size(FDVar) = Size\n This function returns the size of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_size(${1:FDVar})$0"},"cp:fd_true/2":{"prefix":"fd_true","description":"fd_true(FDVar, Elm)\n This predicate is true if the integer Elm is an element in the domain of FDVar.\n","body":"fd_true(${1:FDVar}, ${2:Elm})$0"},"cp:fd_vector_min_max/2":{"prefix":"fd_vector_min_max","description":"fd_vector_min_max(Min,Max)\n When the arguments are integers, this predicate specifies the range of bit vectors; when the arguments are variables, this predicate binds them to the current bounds of the range. The default range is -3200..3200. \n","body":"fd_vector_min_max(${1:Min}, ${2:Max})$0"},"cp:regular/6":{"prefix":"regular","description":"regular(L, Q, S, M, Q0, F)\n Given a finite automaton (DFA or NFA) of Q states numbered 1, 2, ..., Q with input 1..S, transition matrix M, initial state Q0 (1 ? Q0 ? Q), and a list of accepting states F, this constraint is true if the list L is accepted by the automaton. The transition matrix M represents a mapping from 1..Q 1..S to 0..Q, where 0 denotes the error state. For a DFA, every entry in M is an integer, and for an NFA, entries can be a list of integers.\n","body":"regular(${1:L}, ${2:Q}, ${3:S}, ${4:M}, ${5:Q0}, ${6:Fs})$0"},"cp:regular_cp/7":{"prefix":"regular_cp","description":"regular_cp(L, _Q, _S, _M, _Q0, _Fs, _Solver)","body":"regular_cp(${1:L}, ${2:_Q}, ${3:_S}, ${4:_M}, ${5:_Q0}, ${6:_Fs}, ${7:_Solver})$0"},"cp:regular_cp_aux/7":{"prefix":"regular_cp_aux","description":"regular_cp_aux(W, Q, S, M, Q0, Fs, Solver)","body":"regular_cp_aux(${1:W}, ${2:Q}, ${3:S}, ${4:M}, ${5:Q0}, ${6:Fs}, ${7:Solver})$0"},"cp:preprocess_regular_cp/7":{"prefix":"preprocess_regular_cp","description":"preprocess_regular_cp(Q,S,Matrix,Q0,FsLst,Visited,N)","body":"preprocess_regular_cp(${1:Q}, ${2:S}, ${3:Matrix}, ${4:Q0}, ${5:FsLst}, ${6:Visited}, ${7:N})$0"},"cp:lex_le/2":{"prefix":"lex_le","description":"lex_le(L_1 ,L_2 )\n The sequence (an array or a list) L_1 is lexicographically less than or equal to L_2 .\n","body":"lex_le(${1:L1}, ${2:L2})$0"},"cp:lex_lt/2":{"prefix":"lex_lt","description":"lex_lt(L_1 ,L_2 )\n The sequence (an array or a list) L_1 is lexicographically less than L_2 .\n","body":"lex_lt(${1:L1}, ${2:L2})$0"},"cp:check_args_lex/4":{"prefix":"check_args_lex","description":"check_args_lex(L1,L2,L11,L22)","body":"check_args_lex(${1:L1}, ${2:L2}, ${3:L11}, ${4:L22})$0"},"cp:lex_le_aux/2":{"prefix":"lex_le_aux","description":"lex_le_aux([X|Xs],[Y|Ys])","body":"lex_le_aux(${1:[X|Xs]}, ${2:[Y|Ys]})$0"},"cp:watch_lex_le/4":{"prefix":"watch_lex_le","description":"watch_lex_le(X,Y,Xs,Ys)","body":"watch_lex_le(${1:X}, ${2:Y}, ${3:Xs}, ${4:Ys})$0"},"cp:lex_lt_aux/2":{"prefix":"lex_lt_aux","description":"lex_lt_aux([X|Xs],[Y|Ys])","body":"lex_lt_aux(${1:[X|Xs]}, ${2:[Y|Ys]})$0"},"cp:watch_lex_lt/4":{"prefix":"watch_lex_lt","description":"watch_lex_lt(X,Y,Xs,Ys)","body":"watch_lex_lt(${1:X}, ${2:Y}, ${3:Xs}, ${4:Ys})$0"},"cp:nvalue/2":{"prefix":"nvalue","description":"nvalue(N,List)\n The number of distinct values in List is N, where List is a list of integer-domain variables.\n","body":"nvalue(${1:N}, ${2:L})$0"},"cp:matrix_element/4":{"prefix":"matrix_element","description":"matrix_element(Matrix,I,J,V)\n This constraint is true if the entry at <I,J> in Matrix is V, where I, J, and V are integer-domain variables, and Matrix is an two-dimensional array of integer-domain variables.\n","body":"matrix_element(${1:M}, ${2:I}, ${3:J}, ${4:MIJ})$0"},"cp:scalar_product/3":{"prefix":"scalar_product","description":"scalar_product(A,X,Product)\n The scalar product of A and X is Product, where A and X are lists or arrays of integer-domain variables, and Product is an integer-domain variable. A and X must have the same length.\n","body":"scalar_product(${1:A}, ${2:X}, ${3:Product})$0"},"cp:scalar_product/4":{"prefix":"scalar_product","description":"scalar_product(A,X,Rel,Product)\n The scalar product of A and X has the relation Rel with Product, where Rel is one of the following operators: |#=|, |#!=|, |#>=|, |#>|, |#=<| (|#<=|), and |#<|.\n","body":"scalar_product(${1:A}, ${2:X}, ${3:'#<'}, ${4:Product})$0"},"cp:all_different_except_0/1":{"prefix":"all_different_except_0","description":"all_different_except_0(FDVars)\n This constraint is true if all non-zero values in FDVars are different.\n","body":"all_different_except_0(${1:Xs})$0"},"cp:alldifferent_except_0/1":{"prefix":"alldifferent_except_0","description":"alldifferent_except_0(Xs)","body":"alldifferent_except_0(${1:Xs})$0"},"cp:exactly/3":{"prefix":"exactly","description":"exactly(N,L,V)\n: This constraint succeeds if there are exactly N elements in L that are equal to V, where N and V must be integer-domain variables, and L must be a list of integer-domain variables.\n","body":"exactly(${1:N}, ${2:X}, ${3:V})$0"},"cp:at_most/3":{"prefix":"at_most","description":"at_most(N,L,V)\nThis constraint succeeds if there are at most N elements in L that are equal to V, where N and V must be integer-domain variables, and L must be a list of integer-domain variables.\n","body":"at_most(${1:N}, ${2:X}, ${3:V})$0"},"cp:at_least/3":{"prefix":"at_least","description":"at_least(N,L,V)\n* at_most(N,L,V):* circuit(FDVars)* count(V,FDVars,Rel,N)* cumulative(Ss,Ds,Rs,Limit)* decreasing(L)* decreasing_strict(L)* diffn(RectangleList)* disjunctive_tasks(Tasks)(cp only)* element(I,List,V)* exactly(N,L,V):* fd_degree(FDVar) = Degree(cp only)* fd_disjoint(DVar1,DVar2)* fd_dom(FDVar) = List* fd_false(FDVar,Elm)* fd_max(FDVar) = Max* fd_min(FDVar) = Min* fd_min_max(FDVar,Min,Max)* fd_next(FDVar,Elm) = NextElm* fd_prev(FDVar,Elm) = PrevElm* fd_set_false(FDVar,Elm)(cp only)* fd_size(FDVar) = Size* fd_true(FDVar,Elm)* fd_vector_min_max(Min,Max)* global_cardinality(List,Pairs)* increasing(L)* increasing_strict(L)* indomain(Var)(nondet) (cp only)* indomain_down(Var)(nondet) (cp only)* lex_le(L_1 ,L_2 )* lex_lt(L_1 ,L_2 )* matrix_element(Matrix,I,J,V)* neqs(NeqList)(cp only)* new_dvar() = FDVar* new_fd_var() = FDVar* regular(X, Q, S, D, Q0, F)* scalar_product(A,X,Product)* scalar_product(A,X,Rel,Product)* serialized(Starts,Durations)* solve(Options,Vars)(nondet)* solve(Vars)(nondet)* solve_all(Options,Vars) = List* solve_all(Vars) = List* solve_suspended(cp only)* solve_suspended(Options)(cp only)* subcircuit(FDVars)* table_in(DVars,R)* table_notin(DVars,R)\n","body":"at_least(${1:N}, ${2:X}, ${3:V})$0"},"cp:increasing/1":{"prefix":"increasing","description":"increasing(L)\n The sequence (an array or a list) L is in(non-strictly) increasing order.\n","body":"increasing(${1:FDVars})$0"},"cp:increasing_list/1":{"prefix":"increasing_list","description":"increasing_list([X|T@[Y|_]])","body":"increasing_list(${1:[X|T@[Y|_]]})$0"},"cp:increasing_strict/1":{"prefix":"increasing_strict","description":"increasing_strict(L)\n The sequence (an array or a list) L is in strictly increasing order.\n","body":"increasing_strict(${1:FDVars})$0"},"cp:increasing_strict_list/1":{"prefix":"increasing_strict_list","description":"increasing_strict_list([X|T@[Y|_]])","body":"increasing_strict_list(${1:[X|T@[Y|_]]})$0"},"cp:decreasing/1":{"prefix":"decreasing","description":"decreasing(L)\n The sequence (an array or a list) L is in(non-strictly) decreasing order.\n","body":"decreasing(${1:FDVars})$0"},"cp:decreasing_list/1":{"prefix":"decreasing_list","description":"decreasing_list([X|T@[Y|_]])","body":"decreasing_list(${1:[X|T@[Y|_]]})$0"},"cp:decreasing_strict/1":{"prefix":"decreasing_strict","description":"decreasing_strict(L)\n The sequence (an array or a list) L is in strictly decreasing order.\n","body":"decreasing_strict(${1:FDVars})$0"},"cp:decreasing_strict_list/1":{"prefix":"decreasing_strict_list","description":"decreasing_strict_list([X|T@[Y|_]])","body":"decreasing_strict_list(${1:[X|T@[Y|_]]})$0"},"io:at_end_of_stream/1":{"prefix":"at_end_of_stream","description":"at_end_of_stream(FD)\n The at_end_of_streampredicate is demonstrated in the following example. \n","body":"at_end_of_stream(${1:FD})$0"},"io:close/1":{"prefix":"close","description":"close(FD)\n This predicate causes the file to be closed, releasing the file's resources, and removing the file from the file descriptor table. Any further attempts to write to the file descriptorwithout calling openwill cause an error to be thrown. \n","body":"close(${1:FD})$0"},"io:flush/0":{"prefix":"flush","description":"flush()","body":"flush()"},"io:flush/1":{"prefix":"flush","description":"flush(FD)\n This predicate causes all buffered data to be written without delay.\n","body":"flush(${1:FD})$0"},"io:nl/0":{"prefix":"nl","description":"nl","body":"nl"},"io:nl/1":{"prefix":"nl","description":"nl(FD)","body":"nl(${1:FD})$0"},"io:open/1":{"prefix":"open","description":"open(Name) = FD\n The Name parameter is a filename that is represented as a string. This function opens the file with a default read mode.\n","body":"open(${1:Name})$0"},"io:open/2":{"prefix":"open","description":"open(Name, Mode) = FD\n The Mode parameter is one of the four atoms: read, write, or append. The read atom is used for reading from a file; if the file does not exist, or the program tries to write to the file, then the program will throw an error. The write atom is used for reading from a file and writing to a file; if the file already exists, then the file will be overwritten. The append atom is similar to the write atom; however, if the file already exists, then data will be appended at the end of the pre-existing file. \n","body":"open(${1:Name}, ${2:Mode})$0"},"io:peek_byte/1":{"prefix":"peek_byte","description":"peek_byte(FD)","body":"peek_byte(${1:FD})$0"},"io:peek_char/1":{"prefix":"peek_char","description":"peek_char(FD)","body":"peek_char(${1:FD})$0"},"io:print/2":{"prefix":"print","description":"print(FD, Term)\n This predicate prints Term to a file. Unlike the writepredicates, the printpredicates do not place quotes around strings and atoms.\n","body":"print(${1:FD}, ${2:Term})$0"},"io:print/1":{"prefix":"print","description":"print(Term)\n This predicate is the same as print(stdout,Term).\n","body":"print(${1:Term})$0"},"io:printf/2":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format})$0"},"io:printf/3":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format}, ${3:A1})$0"},"io:printf/4":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2})$0"},"io:printf/5":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3})$0"},"io:printf/6":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4})$0"},"io:printf/7":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5})$0"},"io:printf/8":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5}, ${8:A6})$0"},"io:printf/9":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5}, ${8:A6}, ${9:A7})$0"},"io:printf/10":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5}, ${8:A6}, ${9:A7}, ${10:A8})$0"},"io:printf/11":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5}, ${8:A6}, ${9:A7}, ${10:A8}, ${11:A9})$0"},"io:printf/12":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5}, ${8:A6}, ${9:A7}, ${10:A8}, ${11:A9}, ${12:A10})$0"},"io:printf/1":{"prefix":"printf","description":"printf(FD, Format, Args...)\n This predicate is the same as writef, except that printfuses printto display the arguments in the Args parameter, while writefuses writeto display the arguments in the Args parameter. \n","body":"printf(${1:Format})$0"},"io:println/2":{"prefix":"println","description":"println(FD,Term)","body":"println(${1:FD}, ${2:Term})$0"},"io:println/1":{"prefix":"println","description":"println(Term)","body":"println(${1:Term})$0"},"io:read_atom/0":{"prefix":"read_atom","description":"read_atom()","body":"read_atom()"},"io:read_atom/1":{"prefix":"read_atom","description":"read_atom(FD)","body":"read_atom(${1:FD})$0"},"io:read_byte/0":{"prefix":"read_byte","description":"read_byte() = Val\n This function is the same as read_byte(stdin).\n","body":"read_byte()"},"io:read_byte/1":{"prefix":"read_byte","description":"read_byte(FD) = Val\n This function reads a single byte from the file that is represented by FD.\n","body":"read_byte(${1:FD})$0"},"io:read_byte/2":{"prefix":"read_byte","description":"read_byte(FD, N) = List\n This function reads up to N bytes from the file that is represented by FD. It returns the list of bytes that were read.\n","body":"read_byte(${1:FD}, ${2:N})$0"},"io:read_char/0":{"prefix":"read_char","description":"read_char() = Val\n This function is the same as read_char(stdin).\n","body":"read_char()"},"io:read_char/1":{"prefix":"read_char","description":"read_char(FD) = Val\n This function reads a single UTF-8 character from the file that is represented by FD. It returns end_of_file if FD is at the end of the file.\n","body":"read_char(${1:FD})$0"},"io:read_char/2":{"prefix":"read_char","description":"read_char(FD, N) = String\n This function reads up to N UTF-8 characters from the file that is represented by FD. It returns a string that contains the characters that were read.\n","body":"read_char(${1:FD}, ${2:N})$0"},"io:read_char_code/0":{"prefix":"read_char_code","description":"read_char_code() = Val\n This function is the same as read_char_code(stdin).\n","body":"read_char_code()"},"io:read_char_code/1":{"prefix":"read_char_code","description":"read_char_code(FD) = Val\n This function reads a single UTF-8 character from the file that is represented by FD and returns its code point. It returns -1 if FD is at the end of the file.\n","body":"read_char_code(${1:FD})$0"},"io:read_char_code/2":{"prefix":"read_char_code","description":"read_char_code(FD, N) = List\n This function reads up to N UTF-8 characters from the file that is represented by FD. It returns a list of code points of the characters that were read.\n","body":"read_char_code(${1:FD}, ${2:N})$0"},"io:read_file_bytes/0":{"prefix":"read_file_bytes","description":"read_file_bytes() = List\n This function reads an entire byte file from the console into a list.\n","body":"read_file_bytes()"},"io:read_file_bytes/1":{"prefix":"read_file_bytes","description":"read_file_bytes(File) = List\n This function reads an entire byte file into a list.\n","body":"read_file_bytes(${1:File})$0"},"io:read_file_chars/0":{"prefix":"read_file_chars","description":"read_file_chars() = String\n This function reads an entire character file from the console into a string.\n","body":"read_file_chars()"},"io:read_file_chars/1":{"prefix":"read_file_chars","description":"read_file_chars(File) = String\n This function reads an entire character file into a string.\n","body":"read_file_chars(${1:File})$0"},"io:read_file_codes/0":{"prefix":"read_file_codes","description":"read_file_codes() = List\n This function reads UTF-8 codes of an entire character file from the console into a list.\n","body":"read_file_codes()"},"io:read_file_codes/1":{"prefix":"read_file_codes","description":"read_file_codes(File) = List\n This function reads UTF-8 codes of an entire character file into a list.\n","body":"read_file_codes(${1:File})$0"},"io:read_file_lines/0":{"prefix":"read_file_lines","description":"read_file_lines() = Lines\n This function reads an entire character file from the console into a list of line strings.\n","body":"read_file_lines()"},"io:read_file_lines/1":{"prefix":"read_file_lines","description":"read_file_lines(File) = Lines\n This function reads an entire character file into a list of line strings.\n","body":"read_file_lines(${1:File})$0"},"io:read_file_terms/0":{"prefix":"read_file_terms","description":"read_file_terms() = Lines\n This function reads an entire text file from the console into a list of terms. \n","body":"read_file_terms()"},"io:read_file_terms/1":{"prefix":"read_file_terms","description":"read_file_terms(File) = Lines\n This function reads an entire text file into a list of terms. In the file, each term must be terminated by '.' followed by at least one white space.\n","body":"read_file_terms(${1:File})$0"},"io:read_int/0":{"prefix":"read_int","description":"read_int() = Int\n This function is the same as read_int(stdin).\n","body":"read_int()"},"io:read_int/1":{"prefix":"read_int","description":"read_int(FD) = Int\n This function reads a single integer from the file that is represented by FD. It throws an input_mismatch exception if FD is at the end of the file or the next token at FD is not an integer.\n","body":"read_int(${1:FD})$0"},"io:read_line/0":{"prefix":"read_line","description":"read_line() = String\n This function is the same as read_line(stdin).\n","body":"read_line()"},"io:read_line/1":{"prefix":"read_line","description":"read_line(FD) = String\n This function reads a string from the file that is represented by FD, stopping when either a newline ('\\r\\n' on Windows, and '\\n' on Unix) is read, or the end_of_file atom is returned. The newline is not stored in the returned string.\n","body":"read_line(${1:FD})$0"},"io:read_number/0":{"prefix":"read_number","description":"read_number()","body":"read_number()"},"io:read_number/1":{"prefix":"read_number","description":"read_number(FD)","body":"read_number(${1:FD})$0"},"io:read_picat_token/0":{"prefix":"read_picat_token","description":"read_picat_token() = TokenValue\n This function is the same as the above, except that it reads from stdin.\n","body":"read_picat_token()"},"io:read_picat_token/1":{"prefix":"read_picat_token","description":"read_picat_token(FD) = TokenValue\n This function reads a single Picat token from the file that is represented by FD and returns the token value.\n","body":"read_picat_token(${1:FD})$0"},"io:read_picat_token/3":{"prefix":"read_picat_token","description":"read_picat_token(FD,TokenType,TokenValue)\n This predicate reads a single Picat token from the file that is represented by FD. TokenType is the type and TokenValue is the value of the token. TokenType is one of the following: atom, end_of_file, end_of_rule, integer, punctuation, real, string, underscore, and var.\n","body":"read_picat_token(${1:FD}, ${2:TokenType}, ${3:TokenVal})$0"},"io:read_picat_token/2":{"prefix":"read_picat_token","description":"read_picat_token(TokenType,TokenValue)\n This predicate reads a token from stdin.\n","body":"read_picat_token(${1:TokenType}, ${2:TokenVal})$0"},"io:read_real/0":{"prefix":"read_real","description":"read_real() = Real\n This function is the same as read_real(stdin).\n","body":"read_real()"},"io:read_real/1":{"prefix":"read_real","description":"read_real(FD) = Real\n This function reads a single real number from the file that is represented by FD. It throws an input_mismatch exception if FD is at the end of the file or the next token at FD is not a number.\n","body":"read_real(${1:FD})$0"},"io:read_term/0":{"prefix":"read_term","description":"read_term() = Term\n This function is the same as read_term(stdin).\n","body":"read_term()"},"io:read_term/1":{"prefix":"read_term","description":"read_term(FD) = Term\n This function reads a single Picat term from the file that is represented by FD. The term must be followed by a dot '.' and at least one whitespace character. This function consumes the dot symbol. The whitespace character is not stored in the returned string.\n","body":"read_term(${1:FD})$0"},"io:readln/0":{"prefix":"readln","description":"readln() = String\n This function is the same as readln(stdin).\n","body":"readln()"},"io:readln/1":{"prefix":"readln","description":"readln(FD) = String\n This function does the same thing as read_line.\n","body":"readln(${1:FD})$0"},"io:write/2":{"prefix":"write","description":"write(FD, Term)\n This predicate writes Term to a file. Single-character lists are treated as strings. Strings are double-quoted, and atoms are single-quoted when necessary. This predicate does not print a newline, meaning that the next write will begin on the same line.\n","body":"write(${1:FD}, ${2:Term})$0"},"io:write/1":{"prefix":"write","description":"write(Term)\n This predicate is the same as write(stdout,Term).\n","body":"write(${1:Term})$0"},"io:write_byte/1":{"prefix":"write_byte","description":"write_byte(Bytes)\n This predicate is the same as write_byte(stdout,Bytes).\n","body":"write_byte(${1:Bytes})$0"},"io:write_byte/2":{"prefix":"write_byte","description":"write_byte(FD, Bytes)\n This predicate writes a single byte or a list of bytes to a file.\n","body":"write_byte(${1:FD}, ${2:Bytes})$0"},"io:write_char/1":{"prefix":"write_char","description":"write_char(Chars)\n This predicate is the same as write_char(stdout,Chars).\n","body":"write_char(${1:Chars})$0"},"io:write_char/2":{"prefix":"write_char","description":"write_char(FD, Chars)\n This predicate writes a single character or a list of characters to a file. The characters are not quoted. When writing a single-character atom Char, write_char(FD, Char) is the same as print(FD, Char), but write_char is faster than print.\n","body":"write_char(${1:FD}, ${2:Chars})$0"},"io:write_char_code/1":{"prefix":"write_char_code","description":"write_char_code(Codes)\n This predicate is the same as the above, except that it writes to stdout.\n","body":"write_char_code(${1:Codes})$0"},"io:write_char_code/2":{"prefix":"write_char_code","description":"write_char_code(FD, Codes)\n This predicate writes a single character or a list of characters of the given code or list of codes to a file.\n","body":"write_char_code(${1:FD}, ${2:Codes})$0"},"io:writef/3":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:FD}, ${2:Format}, ${3:A1})$0"},"io:writef/4":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2})$0"},"io:writef/5":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3})$0"},"io:writef/6":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4})$0"},"io:writef/7":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5})$0"},"io:writef/8":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5}, ${8:A6})$0"},"io:writef/9":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5}, ${8:A6}, ${9:A7})$0"},"io:writef/10":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5}, ${8:A6}, ${9:A7}, ${10:A8})$0"},"io:writef/11":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5}, ${8:A6}, ${9:A7}, ${10:A8}, ${11:A9})$0"},"io:writef/12":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:FD}, ${2:Format}, ${3:A1}, ${4:A2}, ${5:A3}, ${6:A4}, ${7:A5}, ${8:A6}, ${9:A7}, ${10:A8}, ${11:A9}, ${12:A10})$0"},"io:writef/1":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:Format})$0"},"io:writef/2":{"prefix":"writef","description":"writef(FD, Format, Args...)\n This predicate is used for formatted writing, where the Format parameter contains format characters that indicate how to print each of the arguments in the Args parameter. The number of arguments in Args... cannot exceed 10. \n","body":"writef(${1:Format}, ${2:A1})$0"},"io:writeln/2":{"prefix":"writeln","description":"writeln(FD, Term)\n This predicate writes Term and a newline, meaning that the next write will begin on the next line.\n","body":"writeln(${1:FD}, ${2:Term})$0"},"io:writeln/1":{"prefix":"writeln","description":"writeln(Term)\n This predicate is the same as writeln(stdout,Term).\n","body":"writeln(${1:Term})$0"},"math:abs/1":{"prefix":"abs","description":"abs(X) = Val\n This function returns the absolute value of X. If X ? 0, then this function returns X. Otherwise, this function returns ?X. \n","body":"abs(${1:X})$0"},"math:acos/1":{"prefix":"acos","description":"acos(X) = Val\n This function returns the arc cosine of X, in radians. The returned value is in the range [0, pi]. X must be in the range [?1, 1]; otherwise, this function throws an error.\n","body":"acos(${1:X})$0"},"math:asin/1":{"prefix":"asin","description":"asin(X) = Val\n This function returns the arc sine of X, in radians. The returned value is in the range [-pi / 2, pi / 2]. X must be in the range [?1, 1]; otherwise, this function throws an error.\n","body":"asin(${1:X})$0"},"math:atan/1":{"prefix":"atan","description":"atan(X) = Val\n This function returns the arc tangent of X, in radians. The returned value is in the range [-pi / 2, pi / 2].\n","body":"atan(${1:X})$0"},"math:atan2/2":{"prefix":"atan2","description":"atan2(X, Y) = Val\n This function returns the arc tangent of Y / X, in radians. X and Y are coordinates. The returned value is in the range [-pi, pi].\n","body":"atan2(${1:X}, ${2:Y})$0"},"math:ceiling/1":{"prefix":"ceiling","description":"ceiling(X) = Val\n This function returns the closest integer that is greater than or equal to X.\n","body":"ceiling(${1:X})$0"},"math:cos/1":{"prefix":"cos","description":"cos(X) = Val\n This function returns the cosine of X, where X is given in radians.\n","body":"cos(${1:X})$0"},"math:even/1":{"prefix":"even","description":"even(N)\n This predicate is true if N is an even integer.\n","body":"even(${1:X})$0"},"math:exp/1":{"prefix":"exp","description":"exp(X) = Val\n This function returns e^X .\n","body":"exp(${1:X})$0"},"math:factorial/1":{"prefix":"factorial","description":"factorial(N)","body":"factorial(${1:N})$0"},"math:floor/1":{"prefix":"floor","description":"floor(X) = Val\n This function returns the closest integer that is less than or equal to X.\n","body":"floor(${1:X})$0"},"math:frand/0":{"prefix":"frand","description":"frand() = Val\n This function returns a random real number between 0.0 and 1.0.\n","body":"frand()"},"math:frand/2":{"prefix":"frand","description":"frand(Low,High)","body":"frand(${1:Low}, ${2:High})$0"},"math:gcd/2":{"prefix":"gcd","description":"gcd(A,B)\n This function returns the greatest common divisor of integer A and integer B.\n","body":"gcd(${1:A}, ${2:B})$0"},"math:log/2":{"prefix":"log","description":"log(B, X) = Val\n This function returns log_B (X). \n","body":"log(${1:B}, ${2:X})$0"},"math:log/1":{"prefix":"log","description":"log(X) = Val\n This function returns log_e (X).\n","body":"log(${1:X})$0"},"math:log10/1":{"prefix":"log10","description":"log10(X) = Val\n This function returns log_10 (X).\n","body":"log10(${1:X})$0"},"math:log2/1":{"prefix":"log2","description":"log2(X) = Val\n This function returns log_2 (X).\n","body":"log2(${1:X})$0"},"math:modf/1":{"prefix":"modf","description":"modf(X) = (IntVal,FractVal)\n This function splits a real number into its integer part and its fractional part. \n","body":"modf(${1:X})$0"},"math:odd/1":{"prefix":"odd","description":"odd(N)\n This predicate is true if N is an odd integer.\n","body":"odd(${1:X})$0"},"math:pi/0":{"prefix":"pi","description":"pi","body":"pi"},"math:pow/2":{"prefix":"pow","description":"pow(X, Y) = Val\n This function returns X^Y . It does the same thing as X ** Y.\n","body":"pow(${1:X}, ${2:Y})$0"},"math:pow_mod/3":{"prefix":"pow_mod","description":"pow_mod(X, Y, Z) = Val\n This function returns X^Y mod Z. All of the arguments must be integers, and Y must not be negative.\n","body":"pow_mod(${1:X}, ${2:Y}, ${3:Z})$0"},"math:prime/1":{"prefix":"prime","description":"prime(N)\n This predicate is true if N is a prime number.\n","body":"prime(${1:X})$0"},"math:rand_max/0":{"prefix":"rand_max","description":"rand_max() = Val\n This function returns the maximum random integer.\n","body":"rand_max()"},"math:random/0":{"prefix":"random","description":"random() = Val\n This function returns a random integer.\n","body":"random()"},"math:random/2":{"prefix":"random","description":"random(Low,High)","body":"random(${1:Low}, ${2:High})$0"},"math:random/1":{"prefix":"random","description":"random(Seed) = Val\n This function returns a random integer. At the same time, it changes the seed of the random number generator.\n","body":"random(${1:Seed})$0"},"math:random2/0":{"prefix":"random2","description":"random2() = Val\n This function returns a random integer, using an environment-dependent seed.\n","body":"random2()"},"math:round/1":{"prefix":"round","description":"round(X) = Val\n This function returns the integer that is closest to X.\n","body":"round(${1:X})$0"},"math:sign/1":{"prefix":"sign","description":"sign(X) = Val\n This function determines whether X is positive or negative. If X is positive, then this function returns 1. If X is negative, then this function returns ?1. If X is 0, then this function returns 0.\n","body":"sign(${1:X})$0"},"math:sin/1":{"prefix":"sin","description":"sin(X) = Val\n This function returns the sine of X, where X is given in radians.\n","body":"sin(${1:X})$0"},"math:sqrt/1":{"prefix":"sqrt","description":"sqrt(X) = Val\n This function returns the square root of X. Note that the math module does not support imaginary numbers. Therefore, if X< 0, this function throws an error.\n","body":"sqrt(${1:X})$0"},"math:tan/1":{"prefix":"tan","description":"tan(X) = Val\n This function returns the tangent of X, where X is given in radians. If the tangent is undefined, such as at pi / 2, then this function throws an error.\n","body":"tan(${1:X})$0"},"math:to_degrees/1":{"prefix":"to_degrees","description":"to_degrees(Radian) = Degree\n This function converts from radians to degrees. \n","body":"to_degrees(${1:X})$0"},"math:to_radians/1":{"prefix":"to_radians","description":"to_radians(Degree) = Radian\n This function converts from degrees to radians.\n","body":"to_radians(${1:X})$0"},"math:truncate/1":{"prefix":"truncate","description":"truncate(X) = Val\n This function removes the fractional part from a real number.\n","body":"truncate(${1:X})$0"},"math:sec/1":{"prefix":"sec","description":"sec(X) = Val\n This function returns the secant of X, where X is given in radians. If cos(X) is 0, then this function throws an error.\n","body":"sec(${1:X})$0"},"math:csc/1":{"prefix":"csc","description":"csc(X) = Val\n This function returns the cosecant of X, where X is given in radians. If sin(X) is 0, then this function throws an error.\n","body":"csc(${1:X})$0"},"math:cot/1":{"prefix":"cot","description":"cot(X) = Val\n This function returns the cotangent of X, where X is given in radians. If tan(X) is 0, then this function throws an error.\n","body":"cot(${1:X})$0"},"math:asec/1":{"prefix":"asec","description":"asec(X) = Val\n This function returns the arc secant of X, in radians. The returned value is in the range [0, pi]. X must be in the range (??, ?1] or [1, ?); otherwise, this function throws an error.\n","body":"asec(${1:X})$0"},"math:acsc/1":{"prefix":"acsc","description":"acsc(X) = Val\n This function returns the arc cosecant of X, in radians. The returned value is in the range [-pi / 2, pi / 2]. X must be in the range (??, ?1] or [1, ?); otherwise, this function throws an error.\n","body":"acsc(${1:X})$0"},"math:acot/1":{"prefix":"acot","description":"acot(X) = Val\n This function returns the arc cotangent of X, in radians. The returned value is in the range [-pi / 2, pi / 2]. \n","body":"acot(${1:X})$0"},"math:sinh/1":{"prefix":"sinh","description":"sinh(X) = Val","body":"sinh(${1:X})$0"},"math:cosh/1":{"prefix":"cosh","description":"cosh(X) = Val","body":"cosh(${1:X})$0"},"math:tanh/1":{"prefix":"tanh","description":"tanh(X) = Val","body":"tanh(${1:X})$0"},"math:sech/1":{"prefix":"sech","description":"sech(X) = Val","body":"sech(${1:X})$0"},"math:csch/1":{"prefix":"csch","description":"csch(X) = Val","body":"csch(${1:X})$0"},"math:coth/1":{"prefix":"coth","description":"coth(X) = Val","body":"coth(${1:X})$0"},"math:asinh/1":{"prefix":"asinh","description":"asinh(X) = Val","body":"asinh(${1:X})$0"},"math:acosh/1":{"prefix":"acosh","description":"acosh(X) = Val","body":"acosh(${1:X})$0"},"math:atanh/1":{"prefix":"atanh","description":"atanh(X) = Val","body":"atanh(${1:X})$0"},"math:asech/1":{"prefix":"asech","description":"asech(X) = Val","body":"asech(${1:X})$0"},"math:acsch/1":{"prefix":"acsch","description":"acsch(X) = Val","body":"acsch(${1:X})$0"},"math:acoth/1":{"prefix":"acoth","description":"acoth(X) = Val","body":"acoth(${1:X})$0"},"mip:fd_disjoint/2":{"prefix":"fd_disjoint","description":"fd_disjoint(FDVar1, FDVar2)\n This predicate is true if FDVar1's domain and FDVar2's domain are disjoint.\n","body":"fd_disjoint(${1:DVar1}, ${2:DVar2})$0"},"mip:solve/1":{"prefix":"solve","description":"solve(Vars)\n This predicate is the same as solve([], Vars).\n","body":"solve(${1:Vars})$0"},"mip:solve/2":{"prefix":"solve","description":"solve(Options, Vars)\n This predicate calls the imported solver to label the variables Vars with values, where Options is a list of options for the solver. The options will be detailed below. For cp and sat, this predicate can backtrack in order to find multiple solutions. However, for mip, this call cannot backtrack. The cp module allows incremental labeling of variables, and some variables that occur in constraints but are not passed to solve may remain uninstantiated after a call to solve. The user is responsible for having all the variables that need to be instantiated passed to solve. In constrast, the sat module does not support incremental labeling of variables; once a call to solve succeeds, all the variables in constraints, whether they are passed to solve or not, will be instantiated when solve succeeds.\n","body":"solve(${1:Options}, ${2:Vars})$0"},"mip:solve_all/1":{"prefix":"solve_all","description":"solve_all(Vars)","body":"solve_all(${1:Vars})$0"},"mip:solve_all/2":{"prefix":"solve_all","description":"solve_all(Options, Vars) = Solutions\n This function returns all the solutions that satisfy the constraints.^2 <#note10>* solve_all(Vars) = Solutions: This function is the same as solve_all([],Vars).\n","body":"solve_all(${1:Options}, ${2:Vars})$0"},"mip:new_fd_var/0":{"prefix":"new_fd_var","description":"new_fd_var() = FDVar","body":"new_fd_var() = FDVar"},"mip:new_dvar/0":{"prefix":"new_dvar","description":"new_dvar() = FDVar\n This function creates a new domain variable with the default domain, which has the bounds-72057594037927935..72057594037927935 on 64-bit computers and-268435455..268435455 on 32-bit computers. \n","body":"new_dvar() = FDVar"},"mip:notin/2":{"prefix":"notin","description":"notin(Vars,Domain)","body":"notin(${1:Vars}, ${2:Domain})$0"},"mip:fd_dom/1":{"prefix":"fd_dom","description":"fd_dom(FDVar) = List\n This function returns the domain of FDVar as a list, where FDVar is an integer-domain variable. If FDVar is an integer, then the returned list contains the integer itself.\n","body":"fd_dom(${1:FDVar})$0"},"mip:fd_false/2":{"prefix":"fd_false","description":"fd_false(FDVar, Elm)\n This predicate is true if the integer Elm is not an element in the domain of FDVar.\n","body":"fd_false(${1:FDVar}, ${2:Elm})$0"},"mip:fd_max/1":{"prefix":"fd_max","description":"fd_max(FDVar) = Max\n This function returns the upper bound of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_max(${1:FDVar})$0"},"mip:fd_min/1":{"prefix":"fd_min","description":"fd_min(FDVar) = Min\n This function returns the lower bound of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_min(${1:FDVar})$0"},"mip:fd_min_max/3":{"prefix":"fd_min_max","description":"fd_min_max(FDVar, Min, Max)\n This predicate binds Min to the lower bound of the domain of FDVar, and binds Max to the upper bound of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_min_max(${1:FDVar}, ${2:Min}, ${3:Max})$0"},"mip:fd_next/2":{"prefix":"fd_next","description":"fd_next(FDVar, Elm) = NextElm\n This function returns the next element of Elm in FDVar's domain. It throws an exception if Elm has no next element in FDVar's domain.\n","body":"fd_next(${1:FDVar}, ${2:Elm})$0"},"mip:fd_prev/2":{"prefix":"fd_prev","description":"fd_prev(FDVar, Elm) = PrevElm\n This function returns the previous element of Elm in FDVar's domain. It throws an exception if Elm has no previous element in FDVar's domain.\n","body":"fd_prev(${1:FDVar}, ${2:Elm})$0"},"mip:fd_size/1":{"prefix":"fd_size","description":"fd_size(FDVar) = Size\n This function returns the size of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_size(${1:FDVar})$0"},"mip:fd_true/2":{"prefix":"fd_true","description":"fd_true(FDVar, Elm)\n This predicate is true if the integer Elm is an element in the domain of FDVar.\n","body":"fd_true(${1:FDVar}, ${2:Elm})$0"},"mip:fd_vector_min_max/2":{"prefix":"fd_vector_min_max","description":"fd_vector_min_max(Min,Max)\n When the arguments are integers, this predicate specifies the range of bit vectors; when the arguments are variables, this predicate binds them to the current bounds of the range. The default range is -3200..3200. \n","body":"fd_vector_min_max(${1:Min}, ${2:Max})$0"},"mip:all_distinct/1":{"prefix":"all_distinct","description":"all_distinct(FDVars)\n This constraint is the same as all_different, but it maintains a higher level of consistency. For some problems, this constraint is faster and requires fewer backtracks than all_different, and, for some other problems, this constraint is slower due to the overhead of consistency checking.\n","body":"all_distinct(${1:FDVars})$0"},"mip:all_different/1":{"prefix":"all_different","description":"all_different(FDVars)\n This constraint ensures that each pair of variables in the list or array FDVars is different. This constraint is compiled into a set of inequality constraints. For each pair of variables V1 and V2 in FDVars, all_different(FDVars)generates the constraint V1|#!=|V2.\n","body":"all_different(${1:FDVars})$0"},"mip:alldifferent_aux/1":{"prefix":"alldifferent_aux","description":"alldifferent_aux(Arr)","body":"alldifferent_aux(${1:Arr})$0"},"mip:alldifferent_except_0/1":{"prefix":"alldifferent_except_0","description":"alldifferent_except_0(Xs)","body":"alldifferent_except_0(${1:Xs})$0"},"mip:all_different_except_0/1":{"prefix":"all_different_except_0","description":"all_different_except_0(FDVars)\n This constraint is true if all non-zero values in FDVars are different.\n","body":"all_different_except_0(${1:Xs})$0"},"mip:scalar_product/3":{"prefix":"scalar_product","description":"scalar_product(A,X,Product)\n The scalar product of A and X is Product, where A and X are lists or arrays of integer-domain variables, and Product is an integer-domain variable. A and X must have the same length.\n","body":"scalar_product(${1:A}, ${2:X}, ${3:Product})$0"},"mip:scalar_product/4":{"prefix":"scalar_product","description":"scalar_product(A,X,Rel,Product)\n The scalar product of A and X has the relation Rel with Product, where Rel is one of the following operators: |#=|, |#!=|, |#>=|, |#>|, |#=<| (|#<=|), and |#<|.\n","body":"scalar_product(${1:A}, ${2:X}, ${3:'#<'}, ${4:Product})$0"},"mip:exactly/3":{"prefix":"exactly","description":"exactly(N,L,V)\n: This constraint succeeds if there are exactly N elements in L that are equal to V, where N and V must be integer-domain variables, and L must be a list of integer-domain variables.\n","body":"exactly(${1:N}, ${2:X}, ${3:V})$0"},"mip:at_most/3":{"prefix":"at_most","description":"at_most(N,L,V)\nThis constraint succeeds if there are at most N elements in L that are equal to V, where N and V must be integer-domain variables, and L must be a list of integer-domain variables.\n","body":"at_most(${1:N}, ${2:X}, ${3:V})$0"},"mip:at_least/3":{"prefix":"at_least","description":"at_least(N,L,V)\n* at_most(N,L,V):* circuit(FDVars)* count(V,FDVars,Rel,N)* cumulative(Ss,Ds,Rs,Limit)* decreasing(L)* decreasing_strict(L)* diffn(RectangleList)* disjunctive_tasks(Tasks)(cp only)* element(I,List,V)* exactly(N,L,V):* fd_degree(FDVar) = Degree(cp only)* fd_disjoint(DVar1,DVar2)* fd_dom(FDVar) = List* fd_false(FDVar,Elm)* fd_max(FDVar) = Max* fd_min(FDVar) = Min* fd_min_max(FDVar,Min,Max)* fd_next(FDVar,Elm) = NextElm* fd_prev(FDVar,Elm) = PrevElm* fd_set_false(FDVar,Elm)(cp only)* fd_size(FDVar) = Size* fd_true(FDVar,Elm)* fd_vector_min_max(Min,Max)* global_cardinality(List,Pairs)* increasing(L)* increasing_strict(L)* indomain(Var)(nondet) (cp only)* indomain_down(Var)(nondet) (cp only)* lex_le(L_1 ,L_2 )* lex_lt(L_1 ,L_2 )* matrix_element(Matrix,I,J,V)* neqs(NeqList)(cp only)* new_dvar() = FDVar* new_fd_var() = FDVar* regular(X, Q, S, D, Q0, F)* scalar_product(A,X,Product)* scalar_product(A,X,Rel,Product)* serialized(Starts,Durations)* solve(Options,Vars)(nondet)* solve(Vars)(nondet)* solve_all(Options,Vars) = List* solve_all(Vars) = List* solve_suspended(cp only)* solve_suspended(Options)(cp only)* subcircuit(FDVars)* table_in(DVars,R)* table_notin(DVars,R)\n","body":"at_least(${1:N}, ${2:X}, ${3:V})$0"},"mip:assignment/2":{"prefix":"assignment","description":"assignment(FDVars1, FDVars2)\n This constraint ensures that FDVars2 is a /dual assignment/ of FDVars1, i.e., if the ith element of FDVars1 is j, then the jth element of FDVars2 is i. The constraint can be defined as:\n","body":"assignment(${1:FDVars1}, ${2:FDVars2})$0"},"mip:circuit/1":{"prefix":"circuit","description":"circuit(FDVars)\n Let FDVars be a list of variables [X_1 ,X_2 ,...,X_N], where each X_i has the domain 1..N. A valuation X_1 =v_1 , X_2=v_2 , ..., X_n =v_n satisfies the constraint if 1->v_1 , 2->v_2 ,..., n->v_n forms a Hamiltonian cycle. This constraint ensures that each variable has a different value, and that the graph that is formed by the assignment does not contain any sub-cycles. For example, for the constraint\n","body":"circuit(${1:L})$0"},"mip:circuit_aux/1":{"prefix":"circuit_aux","description":"circuit_aux(A)","body":"circuit_aux(${1:A})$0"},"mip:and Xi/0":{"prefix":"and Xi","description":"and Xi","body":"and Xi"},"mip:subcircuit/1":{"prefix":"subcircuit","description":"subcircuit(FDVars)\n This constraint is the same as circuit(FDVars), except that not all of the vertices are required to be in the circuit. If the ith element of FDVars is i, then the vertex i is not part of the circuit. This constraint is only accepted by cp and sat.\n","body":"subcircuit(${1:L})$0"},"mip:subcircuit_aux/1":{"prefix":"subcircuit_aux","description":"subcircuit_aux(A)","body":"subcircuit_aux(${1:A})$0"},"mip:count/4":{"prefix":"count","description":"count(V, FDVars, Rel, N)\n In this constraint, V and N are integer-domain variables, FDVars is a list of integer-domain variables, and Rel is an arithmetic constraint operator (|#=|,|#!=|, |#>|, |#>=|, |#<|, |#=<|, or |#<=|). Let Count be the number of elements in FDVars that are equal to V. The constraint is true iff Count Rel N is true. This constraint can be defined as follows:\n","body":"count(${1:V}, ${2:FDVars}, ${3:Rel}, ${4:N})$0"},"mip:reified_bool_vars/3":{"prefix":"reified_bool_vars","description":"reified_bool_vars([E|List],V,Bs)","body":"reified_bool_vars(${1:[E|List]}, ${2:V}, ${3:Bs})$0"},"mip:count_aux/3":{"prefix":"count_aux","description":"count_aux(Bs,'#<=',N)","body":"count_aux(${1:Bs}, ${2:'#<='}, ${3:N})$0"},"mip:count/3":{"prefix":"count","description":"count(V,FDVars,N)","body":"count(${1:V}, ${2:FDVars}, ${3:N})$0"},"mip:cumulative/4":{"prefix":"cumulative","description":"cumulative(Starts, Durations, Resources, Limit)\n This constraint is useful for describing and solving scheduling problems. The arguments Starts, Durations, and Resources are lists of integer-domain variables of the same length, and Limit is an integer-domain variable. Let Starts be [S_1 , S_2 , ..., S_n ], Durations be [D_1 , D_2 , ..., D_n ], and Resources be [R_1 , R_2 , ..., R_n ]. For each job i, S_i represents the start time, D_i represents the duration, and R_i represents the units of resources needed. Limit is the limit on the units of resources available at any time. This constraint ensures that the limit cannot be exceeded at any time.\n","body":"cumulative(${1:Starts}, ${2:Durations}, ${3:Resources}, ${4:Limit})$0"},"mip:decreasing/1":{"prefix":"decreasing","description":"decreasing(L)\n The sequence (an array or a list) L is in(non-strictly) decreasing order.\n","body":"decreasing(${1:FDVars})$0"},"mip:decreasing_list/1":{"prefix":"decreasing_list","description":"decreasing_list([X|T@[Y|_]])","body":"decreasing_list(${1:[X|T@[Y|_]]})$0"},"mip:decreasing_strict/1":{"prefix":"decreasing_strict","description":"decreasing_strict(L)\n The sequence (an array or a list) L is in strictly decreasing order.\n","body":"decreasing_strict(${1:FDVars})$0"},"mip:decreasing_strict_list/1":{"prefix":"decreasing_strict_list","description":"decreasing_strict_list([X|T@[Y|_]])","body":"decreasing_strict_list(${1:[X|T@[Y|_]]})$0"},"mip:diffn/1":{"prefix":"diffn","description":"diffn(RectangleList)\n This constraint ensures that no two rectangles in RectangleList overlap with each other. A rectangle in an n-dimensional space is represented by a list of 2 n elements [X_1 , X_2 , ..., X_n , S_1 , S_2 , ..., S_n ], where X_i is the starting coordinate of the edge in the ith dimension, and S_i is the size of the edge.\n","body":"diffn(${1:RectangleList})$0"},"mip:disjunctive_tasks/1":{"prefix":"disjunctive_tasks","description":"disjunctive_tasks(Tasks)\n Tasks is a list of terms. Each term has the form disj_tasks(S_1 ,D_1 ,S_2 ,D_2 ), where S_1 and S_2 are two integer-domain variables, and D_1 and D_2 are two positive integers. This constraint is equivalent to posting the disjunctive constraint S_1 +D_1 |#=<| S_2 |#\\/| S_2 +D_2 |#=<| S_1 for each term disj_tasks(S_1 ,D_1 ,S_2 ,D_2 ) in Tasks; however the constraint may be more efficient, because it converts the disjunctive tasks into global constraints. This constraint is only accepted by cp.\n","body":"disjunctive_tasks(${1:Tasks})$0"},"mip:disjunctive_tasks_aux/1":{"prefix":"disjunctive_tasks_aux","description":"disjunctive_tasks_aux(Tasks)","body":"disjunctive_tasks_aux(${1:Tasks})$0"},"mip:disjunctive_tasks_aux/4":{"prefix":"disjunctive_tasks_aux","description":"disjunctive_tasks_aux([disj_tasks(S1,D1,S2,D2)|Tasks])","body":"disjunctive_tasks_aux(${1:[disj_tasks(S1}, ${2:D1}, ${3:S2}, ${4:D2})$0"},"mip:element/3":{"prefix":"element","description":"element(I, List, V)\n This constraint is true if the Ith element of List is V, where I and V are integer-domain variables, and List is a list of integer-domain variables.\n","body":"element(${1:I}, ${2:FDVars}, ${3:V})$0"},"mip:global_cardinality/2":{"prefix":"global_cardinality","description":"global_cardinality(List, Pairs)\n Let List be a list of integer-domain variables [X_1 , ..., X_d ], and Pairs be a list of pairs [K_1 -V_1 , ..., K_n -V_n ], where each key K_i is a unique integer, and each V_i is an integer-domain variable. The constraint is true if every element of List is equal to some key, and, for each pair K_i -V_i , exactly V_i elements of List are equal to K_i . This constraint can be defined as follows:\n","body":"global_cardinality(${1:List}, ${2:Pairs})$0"},"mip:increasing/1":{"prefix":"increasing","description":"increasing(L)\n The sequence (an array or a list) L is in(non-strictly) increasing order.\n","body":"increasing(${1:FDVars})$0"},"mip:increasing_list/1":{"prefix":"increasing_list","description":"increasing_list([X|T@[Y|_]])","body":"increasing_list(${1:[X|T@[Y|_]]})$0"},"mip:increasing_strict/1":{"prefix":"increasing_strict","description":"increasing_strict(L)\n The sequence (an array or a list) L is in strictly increasing order.\n","body":"increasing_strict(${1:FDVars})$0"},"mip:increasing_strict_list/1":{"prefix":"increasing_strict_list","description":"increasing_strict_list([X|T@[Y|_]])","body":"increasing_strict_list(${1:[X|T@[Y|_]]})$0"},"mip:lex_le/2":{"prefix":"lex_le","description":"lex_le(L_1 ,L_2 )\n The sequence (an array or a list) L_1 is lexicographically less than or equal to L_2 .\n","body":"lex_le(${1:L1}, ${2:L2})$0"},"mip:lex_lt/2":{"prefix":"lex_lt","description":"lex_lt(L_1 ,L_2 )\n The sequence (an array or a list) L_1 is lexicographically less than L_2 .\n","body":"lex_lt(${1:L1}, ${2:L2})$0"},"mip:check_args_lex/4":{"prefix":"check_args_lex","description":"check_args_lex(L1,L2,L11,L22)","body":"check_args_lex(${1:L1}, ${2:L2}, ${3:L11}, ${4:L22})$0"},"mip:lex_le_aux/2":{"prefix":"lex_le_aux","description":"lex_le_aux(L1,L2)","body":"lex_le_aux(${1:L1}, ${2:L2})$0"},"mip:lex_le_aux/4":{"prefix":"lex_le_aux","description":"lex_le_aux([X1,X2],[Y1,Y2|_])","body":"lex_le_aux(${1:[X1}, ${2:X2]}, ${3:[Y1}, ${4:Y2|_]})$0"},"mip:lex_lt_aux/2":{"prefix":"lex_lt_aux","description":"lex_lt_aux(L1,L2)","body":"lex_lt_aux(${1:L1}, ${2:L2})$0"},"mip:lex_lt_aux/4":{"prefix":"lex_lt_aux","description":"lex_lt_aux([X1,X2],[Y1,Y2|_])","body":"lex_lt_aux(${1:[X1}, ${2:X2]}, ${3:[Y1}, ${4:Y2|_]})$0"},"mip:nvalue/2":{"prefix":"nvalue","description":"nvalue(N,List)\n The number of distinct values in List is N, where List is a list of integer-domain variables.\n","body":"nvalue(${1:N}, ${2:L})$0"},"mip:matrix_element/4":{"prefix":"matrix_element","description":"matrix_element(Matrix,I,J,V)\n This constraint is true if the entry at <I,J> in Matrix is V, where I, J, and V are integer-domain variables, and Matrix is an two-dimensional array of integer-domain variables.\n","body":"matrix_element(${1:M}, ${2:I}, ${3:J}, ${4:MIJ})$0"},"mip:regular/6":{"prefix":"regular","description":"regular(L, Q, S, M, Q0, F)\n Given a finite automaton (DFA or NFA) of Q states numbered 1, 2, ..., Q with input 1..S, transition matrix M, initial state Q0 (1 ? Q0 ? Q), and a list of accepting states F, this constraint is true if the list L is accepted by the automaton. The transition matrix M represents a mapping from 1..Q 1..S to 0..Q, where 0 denotes the error state. For a DFA, every entry in M is an integer, and for an NFA, entries can be a list of integers.\n","body":"regular(${1:L}, ${2:_Q}, ${3:_S}, ${4:_M}, ${5:_Q0}, ${6:_Fs})$0"},"mip:regular_aux/6":{"prefix":"regular_aux","description":"regular_aux(W, Q, S, M, Q0, Fs)","body":"regular_aux(${1:W}, ${2:Q}, ${3:S}, ${4:M}, ${5:Q0}, ${6:Fs})$0"},"mip:neqs/1":{"prefix":"neqs","description":"neqs(NeqList)\n NeqList is a list of inequality constraints of the form X |#!=| Y, where X and Y are integer-domain variables. This constraint is equivalent to the conjunction of the inequality constraints in NeqList, but it extracts all_distinctconstraints from the inequality constraints. This constraint is only accepted by cp.\n","body":"neqs(${1:Neqs})$0"},"mip:serialized/2":{"prefix":"serialized","description":"serialized(Starts, Durations)\n This constraint describes a set of non-overlapping tasks, where Starts and Durations are lists of integer-domain variables, and the lists have the same length. Let Os be a list of 1s that has the same length as Starts. This constraint is equivalent to cumulative(Starts,Durations,Os,1).\n","body":"serialized(${1:Starts}, ${2:Durations})$0"},"mip:table_in/2":{"prefix":"table_in","description":"table_in(Vars,Tuples)","body":"table_in(${1:Vars}, ${2:Tuples})$0"},"mip:table_notin/2":{"prefix":"table_notin","description":"table_notin(Vars,Tuples)","body":"table_notin(${1:Vars}, ${2:Tuples})$0"},"ordset:delete/2":{"prefix":"delete","description":"delete(OSet,Elm) = OSet_1 \n This function returns of a copy of OSet that does not contain the element Elm.\n","body":"delete(${1:OSet}, ${2:Elm})$0"},"ordset:disjoint/2":{"prefix":"disjoint","description":"disjoint(OSet_1 ,OSet_2 )\n This predicate is true when OSet_1 and OSet_2 have no element in common.\n","body":"disjoint(${1:OSet1}, ${2:OSet2})$0"},"ordset:insert/2":{"prefix":"insert","description":"insert(OSet,Elm) = OSet_1 \n This function returns a copy of OSet with the element Elm inserted.\n","body":"insert(${1:OSet}, ${2:Elm})$0"},"ordset:intersection/2":{"prefix":"intersection","description":"intersection(OSet_1 ,OSet_2 )=OSet_3 \n This function returns an ordered set that contains elements which are in both OSet_1 and OSet_2 .\n","body":"intersection(${1:OSet1}, ${2:OSet2})$0"},"ordset:membchk/2":{"prefix":"membchk","description":"membchk(Term, List)\n This predicate is true if Term is an element of List.\n","body":"membchk(${1:E}, ${2:OSet})$0"},"ordset:new_ordset/1":{"prefix":"new_ordset","description":"new_ordset(List) = OSet\n This function returns an ordered set that contains the elements of List.\n","body":"new_ordset(${1:List})$0"},"ordset:ordset/1":{"prefix":"ordset","description":"ordset(Term)\n This predicate is true if Term is an ordered set.\n","body":"ordset(${1:Term})$0"},"ordset:subset/2":{"prefix":"subset","description":"subset(OSet_1 ,OSet_2 )\n This predicate is true if OSet_1 is a subset of OSet_2 .\n","body":"subset(${1:OSet1}, ${2:OSet2})$0"},"ordset:subtract/2":{"prefix":"subtract","description":"subtract(OSet_1 ,OSet_2 )=OSet_3 \n This function returns an ordered set that contains all of the elements of OSet_1 which are not in OSet_2 .\n","body":"subtract(${1:OSet1}, ${2:OSet2})$0"},"ordset:union/2":{"prefix":"union","description":"union(OSet_1 ,OSet_2 )=OSet_3 \n This function returns an ordered set that contains all of the elements which are present in either OSet_1 or OSet_2 . \n","body":"union(${1:OSet1}, ${2:OSet2})$0"},"os:chdir/1":{"prefix":"chdir","description":"chdir(String)","body":"chdir(${1:String})$0"},"os:check_path/1":{"prefix":"check_path","description":"check_path(Path)","body":"check_path(${1:Path})$0"},"os:cd/1":{"prefix":"cd","description":"cd(String)","body":"cd(${1:String})$0"},"os:cp/2":{"prefix":"cp","description":"cp(FromPath, ToPath)\n This copies a file from FromPath to ToPath. This predicate will throw an error if FromPath does not exist or FromPath is a directory. An error will also occur if the program does not have permission to read from FromPath, or if it does not have permission to write to ToPath.\n","body":"cp(${1:String1}, ${2:String2})$0"},"os:picat_copy_file/2":{"prefix":"picat_copy_file","description":"picat_copy_file(Path1,Path2)","body":"picat_copy_file(${1:Path1}, ${2:Path2})$0"},"os:picat_copy_file_aux/2":{"prefix":"picat_copy_file_aux","description":"picat_copy_file_aux(Path1,Path2)","body":"picat_copy_file_aux(${1:Path1}, ${2:Path2})$0"},"os:cwd/0":{"prefix":"cwd","description":"cwd() = Path","body":"cwd() = Path"},"os:dir/0":{"prefix":"dir","description":"dir","body":"dir"},"os:directory/1":{"prefix":"directory","description":"directory(Path)\n Does Path refer to a directory? \n","body":"directory(${1:String})$0"},"os:file/1":{"prefix":"file","description":"file(String)","body":"file(${1:String})$0"},"os:file_base_name/1":{"prefix":"file_base_name","description":"file_base_name(Path) = List\n This function returns a string containing the base name of Path. For example, the base name ofa/b/c.txt\" is c.txt\".\n","body":"file_base_name(${1:String})$0"},"os:file_directory_name/1":{"prefix":"file_directory_name","description":"file_directory_name(Path) = List\n This function returns a string containing the path of the directory that contains Path. For example, the directory name of a/b/c.txt\" is a/b/\".\n","body":"file_directory_name(${1:String})$0"},"os:file_exists/1":{"prefix":"file_exists","description":"file_exists(Path)\n This tests whether Path exists, and, if it exists, whether Path refers to a regular file.\n","body":"file_exists(${1:String})$0"},"os:env_exists/1":{"prefix":"env_exists","description":"env_exists(Name)\n This predicate succeeds if Name is an environment variable in the system.\n","body":"env_exists(${1:String})$0"},"os:getenv/1":{"prefix":"getenv","description":"getenv(Name) = String\n This function returns the value of the environment variable Name as a string. This function will throw an error if the environment variable Name does not exist. \n","body":"getenv(${1:String})$0"},"os:executable/1":{"prefix":"executable","description":"executable(String)","body":"executable(${1:String})$0"},"os:exists/1":{"prefix":"exists","description":"exists(Path)\n Is Path an existing file or directory?* file(Path): Does Path refer to a regular file? This predicate is true if Path is neither a directory nor a special file, such as a socket or a pipe.\n","body":"exists(${1:String})$0"},"os:listdir/1":{"prefix":"listdir","description":"listdir(Path) = List\n This function returns a list of all of the files and directories that are contained inside the directory specified by Path. If Path is not a directory, then an error is thrown. The returned list contains strings, each of which is the name of a file or directory. \n","body":"listdir(${1:String})$0"},"os:picat_listdir/2":{"prefix":"picat_listdir","description":"picat_listdir(Path,_List)","body":"picat_listdir(${1:Path}, ${2:_List})$0"},"os:ls/0":{"prefix":"ls","description":"ls","body":"ls"},"os:mkdir/1":{"prefix":"mkdir","description":"mkdir(Path)\n This predicate creates a new directory at location Path. The directory will be created with a default permission list of [rwu, rwg, ro]. If the program does not have permission to write to the parent directory of Path, this predicate will throw an error. An error will also occur if the parent directory does not exist.\n","body":"mkdir(${1:String})$0"},"os:pwd/0":{"prefix":"pwd","description":"pwd()","body":"pwd()"},"os:rename/2":{"prefix":"rename","description":"rename(Old, New)\n This renames a file or a directory from Old to New. This predicate will throw an error if Old does not exist. An error will also occur if the program does not have permission to write to Old or New.\n","body":"rename(${1:String1}, ${2:String2})$0"},"os:readable/1":{"prefix":"readable","description":"readable(Path)\n Is the program allowed to read from the file?* writable(Path): Is the program allowed to write to the file?* executable(Path): Is the program allowed to execute the file?* size(Path) = Int: If Path is not a symbolic link, then this function returns the number of bytes contained in the file to which Path refers. If Path is a symbolic link, then this function returns the path size of the symbolic link. Because the function size/1 is defined in the basic module for returning the size of a map, this function requires an explicit module qualifier os.size(Path).\n","body":"readable(${1:String})$0"},"os:rm/1":{"prefix":"rm","description":"rm(Path)\n This deletes a file. An error will be thrown if the file does not exist, if the program does not have permission to delete the file, or if Path refers to a directory, a hard link, a symbolic link, or a special file type.\n","body":"rm(${1:String})$0"},"os:picat_delete_file/1":{"prefix":"picat_delete_file","description":"picat_delete_file(Name)","body":"picat_delete_file(${1:Name})$0"},"os:rmdir/1":{"prefix":"rmdir","description":"rmdir(Path)\n This deletes a directory. An error will be thrown if the directory does not exist, the program does not have permission to delete the directory, the directory is not empty, or if Path does not refer to a directory. \n","body":"rmdir(${1:Path})$0"},"os:picat_delete_directory/1":{"prefix":"picat_delete_directory","description":"picat_delete_directory(Name)","body":"picat_delete_directory(${1:Name})$0"},"os:separator/0":{"prefix":"separator","description":"separator() = Char","body":"separator() = Char"},"os:size/1":{"prefix":"size","description":"size(Map) = Size\n This function returns the number of pairs in Map. \n","body":"size(${1:String})$0"},"os:writable/1":{"prefix":"writable","description":"writable(String)","body":"writable(${1:String})$0"},"planner:new_state_list/1":{"prefix":"new_state_list","description":"new_state_list(List) = SList","body":"new_state_list(${1:List})$0"},"planner:new_state_list_aux/3":{"prefix":"new_state_list_aux","description":"new_state_list_aux([E|List],SList0,SList)","body":"new_state_list_aux(${1:[E|List]}, ${2:SList0}, ${3:SList})$0"},"planner:insert_state_list/2":{"prefix":"insert_state_list","description":"insert_state_list(SList0,Elm) = SList","body":"insert_state_list(${1:SList0}, ${2:Elm})$0"},"planner:current_resource/0":{"prefix":"current_resource","description":"current_resource()=Amount\n This function returns the current available resource amount of the current node. If the current execution path was not initiated by one of the calls that performs resource-bounded search, then 268435455 is returned. This function can be used to check the heuristics. If the heuristic estimate of the cost to travel from the current state to a final state is greater than the available resource amount, then the current state can be failed.\n","body":"current_resource() = Amount"},"planner:current_plan/0":{"prefix":"current_plan","description":"current_plan()=Plan\n This function returns the current plan that has transformed the initial state to the current state. If the current execution path was not initiated by one of the calls that performs resource-bounded search, then [] is returned.\n","body":"current_plan() = Plan"},"planner:current_resource_plan/2":{"prefix":"current_resource_plan","description":"current_resource_plan(Amount,Plan)","body":"current_resource_plan(${1:Amount}, ${2:Plan})$0"},"planner:current_resource_plan_cost/3":{"prefix":"current_resource_plan_cost","description":"current_resource_plan_cost(Amount,Plan,Cost)\n This predicate retrieves the attributes of the current node in the search tree, including the resource amount, the path to the node, and its cost.\n","body":"current_resource_plan_cost(${1:Amount}, ${2:Plan}, ${3:Cost})$0"},"planner:plan/2":{"prefix":"plan","description":"plan(S,Plan)\n This predicate is the same as the plan/4 predicate, except that the limit is assumed to be 268435455, and that the plan's cost is not returned.\n","body":"plan(${1:_S}, ${2:Plan})$0"},"planner:plan/3":{"prefix":"plan","description":"plan(S,Plan,PlanCost)\nIf the second argument is a variable, then this predicate is the same as the plan/4 predicate, except that the limit is assumed to be 268435455.\n","body":"plan(${1:_S}, ${2:Limit}, ${3:Plan})$0"},"planner:plan/4":{"prefix":"plan","description":"plan(S,Limit,Plan,Cost)\n This predicate, if it succeeds, binds Plan to a plan that can transform state S to a final state that satisfies the condition given by final/1 or final/3. Cost is the cost of Plan, which cannot exceed Limit, which is a given non-negative integer.\n","body":"plan(${1:_S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost})$0"},"planner:plan/5":{"prefix":"plan","description":"plan(_S,Limit,Plan,PlanCost,_FinS)","body":"plan(${1:_S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost}, ${5:_FinS})$0"},"planner:plan_unbounded/2":{"prefix":"plan_unbounded","description":"plan_unbounded(S,Plan)\n This predicate is the same as the above predicate, except that the limit is assumed to be 268435455.\n","body":"plan_unbounded(${1:_S}, ${2:Plan})$0"},"planner:plan_unbounded/3":{"prefix":"plan_unbounded","description":"plan_unbounded(S,Plan,PlanCost)\n If the second argument is an integer, then this predicate is the same as the above predicate, except that the plan's cost is not returned. Otherwise, if the second argument is a variable, then this predicate is the same as the above predicate, except that the limit is assumed to be 268435455.\n","body":"plan_unbounded(${1:_S}, ${2:Limit}, ${3:Plan})$0"},"planner:plan_unbounded/4":{"prefix":"plan_unbounded","description":"plan_unbounded(S,Limit,Plan,Cost)\n This predicate, if it succeeds, binds Plan to a plan that can transform state S to a final state. Cost is the cost of Plan, which cannot exceed Limit, which is a given non-negative integer.\n","body":"plan_unbounded(${1:_S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost})$0"},"planner:best_plan/2":{"prefix":"best_plan","description":"best_plan(S,Plan)\n This predicate is the same as the best_plan/4 predicate, except that the limit is assumed to be 268435455, and that the plan's cost is not returned.\n","body":"best_plan(${1:_S}, ${2:Plan})$0"},"planner:best_plan/3":{"prefix":"best_plan","description":"best_plan(S,Plan,PlanCost)\n If the second argument is a variable, then this predicate is the same as the best_plan/4 predicate, except that the limit is assumed to be 268435455.\n","body":"best_plan(${1:_S}, ${2:Limit}, ${3:Plan})$0"},"planner:best_plan/4":{"prefix":"best_plan","description":"best_plan(S,Limit,Plan,Cost)\n This predicate finds an optimal plan by using the following algorithm: It first calls plan/4 to find a plan of 0 cost. If no plan is found, then it increases the cost limit to 1 or double the cost limit. Once a plan is found, the algorithm uses binary search to find an optimal plan.\n","body":"best_plan(${1:_S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost})$0"},"planner:best_plan/5":{"prefix":"best_plan","description":"best_plan(_S,Limit,Plan,PlanCost,_FinS)","body":"best_plan(${1:_S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost}, ${5:_FinS})$0"},"planner:best_plan_downward/6":{"prefix":"best_plan_downward","description":"best_plan_downward(S,Level,Limit,Plan,PlanCost,FinS)","body":"best_plan_downward(${1:S}, ${2:Level}, ${3:Limit}, ${4:Plan}, ${5:PlanCost}, ${6:FinS})$0"},"planner:best_plan_bin/2":{"prefix":"best_plan_bin","description":"best_plan_bin(_S,Plan)","body":"best_plan_bin(${1:_S}, ${2:Plan})$0"},"planner:best_plan_bin/3":{"prefix":"best_plan_bin","description":"best_plan_bin(_S,Limit,Plan)","body":"best_plan_bin(${1:_S}, ${2:Limit}, ${3:Plan})$0"},"planner:best_plan_bin/4":{"prefix":"best_plan_bin","description":"best_plan_bin(_S,Limit,Plan,PlanCost)","body":"best_plan_bin(${1:_S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost})$0"},"planner:best_plan_bin/5":{"prefix":"best_plan_bin","description":"best_plan_bin(_S,Limit,Plan,PlanCost,_FinS)","body":"best_plan_bin(${1:_S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost}, ${5:_FinS})$0"},"planner:best_plan_downward_bin/6":{"prefix":"best_plan_downward_bin","description":"best_plan_downward_bin(S,Level,Limit,Plan,PlanCost,FinS)","body":"best_plan_downward_bin(${1:S}, ${2:Level}, ${3:Limit}, ${4:Plan}, ${5:PlanCost}, ${6:FinS})$0"},"planner:loop_best_plan_downward_bin/7":{"prefix":"loop_best_plan_downward_bin","description":"loop_best_plan_downward_bin(S,Level,Limit,Plan,PlanCost,FinS,Map)","body":"loop_best_plan_downward_bin(${1:S}, ${2:Level}, ${3:Limit}, ${4:Plan}, ${5:PlanCost}, ${6:FinS}, ${7:Map})$0"},"planner:loop_best_plan_bin/6":{"prefix":"loop_best_plan_bin","description":"loop_best_plan_bin(S,Map,_Lower,_Upper,Plan,PlanCost)","body":"loop_best_plan_bin(${1:S}, ${2:Map}, ${3:_Lower}, ${4:_Upper}, ${5:Plan}, ${6:PlanCost})$0"},"planner:best_plan_nondet/2":{"prefix":"best_plan_nondet","description":"best_plan_nondet(S,Plan)\n This predicate is the same as the best_plan_nondet/4 predicate, except that the limit is assumed to be 268435455, and that the plan's cost is not returned.\n","body":"best_plan_nondet(${1:_S}, ${2:Plan})$0"},"planner:best_plan_nondet/3":{"prefix":"best_plan_nondet","description":"best_plan_nondet(S,Plan,PlanCost)\n If the second argument is a variable, then this predicate is the same as the best_plan_nondet/4 predicate, except that the limit is assumed to be 268435455.\n","body":"best_plan_nondet(${1:_S}, ${2:Limit}, ${3:Plan})$0"},"planner:best_plan_nondet/4":{"prefix":"best_plan_nondet","description":"best_plan_nondet(S,Limit,Plan,Cost)\n This predicate is the same as best_plan(S,Limit,Plan,Cost), except that it allows multiple best plans to be returned through backtracking.\n","body":"best_plan_nondet(${1:_S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost})$0"},"planner:best_plan_nondet_aux/4":{"prefix":"best_plan_nondet_aux","description":"best_plan_nondet_aux(S,Limit,Plan,PlanCost)","body":"best_plan_nondet_aux(${1:S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost})$0"},"planner:best_plan_bb/2":{"prefix":"best_plan_bb","description":"best_plan_bb(S,Plan)\n This predicate is the same as the best_plan_bb/4 predicate, except that the limit is assumed to be 268435455, and that the plan's cost is not returned.\n","body":"best_plan_bb(${1:_S}, ${2:Plan})$0"},"planner:best_plan_bb/3":{"prefix":"best_plan_bb","description":"best_plan_bb(S,Plan,PlanCost)\n If the second argument is a variable, then this predicate is the same as the best_plan_bb/4 predicate, except that the limit is assumed to be 268435455.\n","body":"best_plan_bb(${1:_S}, ${2:Limit}, ${3:Plan})$0"},"planner:best_plan_bb/4":{"prefix":"best_plan_bb","description":"best_plan_bb(S,Limit,Plan,Cost)\n This predicate, if it succeeds, binds Plan to an optimal plan that can transform state S to a final state. Cost is the cost of Plan, which cannot exceed Limit, which is a given non-negative integer. The branch-and-bound algorithm is used to find an optimal plan.\n","body":"best_plan_bb(${1:_S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost})$0"},"planner:loop_best_plan_bb/4":{"prefix":"loop_best_plan_bb","description":"loop_best_plan_bb(S,_Limit,Plan,PlanCost)","body":"loop_best_plan_bb(${1:S}, ${2:_Limit}, ${3:Plan}, ${4:PlanCost})$0"},"planner:call_picat_plan/2":{"prefix":"call_picat_plan","description":"call_picat_plan(S,Limit)","body":"call_picat_plan(${1:S}, ${2:Limit})$0"},"planner:call_picat_plan_aux/2":{"prefix":"call_picat_plan_aux","description":"call_picat_plan_aux(S,Limit)","body":"call_picat_plan_aux(${1:S}, ${2:Limit})$0"},"planner:best_plan_unbounded/2":{"prefix":"best_plan_unbounded","description":"best_plan_unbounded(S,Plan)\n This predicate is the same as the above predicate, except that the limit is assumed to be 268435455. \n","body":"best_plan_unbounded(${1:_S}, ${2:Plan})$0"},"planner:best_plan_unbounded/3":{"prefix":"best_plan_unbounded","description":"best_plan_unbounded(S,Plan,PlanCost)\n If the second argument is an integer, then this predicate is the same as the above predicate, except that the plan's cost is not returned. Otherwise, if the second argument is a variable, then this predicate is the same as the above predicate, except that the limit is assumed to be 268435455.\n","body":"best_plan_unbounded(${1:_S}, ${2:Limit}, ${3:Plan})$0"},"planner:best_plan_unbounded/4":{"prefix":"best_plan_unbounded","description":"best_plan_unbounded(S,Limit,Plan,Cost)\n This predicate, if it succeeds, binds Plan to an optimal plan that can transform state S to a final state. Cost is the cost of Plan, which cannot exceed Limit, which is a given non-negative integer.\n","body":"best_plan_unbounded(${1:_S}, ${2:Limit}, ${3:Plan}, ${4:PlanCost})$0"},"planner:is_tabled_state/1":{"prefix":"is_tabled_state","description":"is_tabled_state(S)\n This predicate succeeds if the state S has been explored before and has been tabled. \n","body":"is_tabled_state(${1:S})$0"},"planner:throw_plan_arg_error/4":{"prefix":"throw_plan_arg_error","description":"throw_plan_arg_error(Limit,_Plan,_PlanCost,Source)","body":"throw_plan_arg_error(${1:Limit}, ${2:_Plan}, ${3:_PlanCost}, ${4:Source})$0"},"sat:all_different/1":{"prefix":"all_different","description":"all_different(FDVars)\n This constraint ensures that each pair of variables in the list or array FDVars is different. This constraint is compiled into a set of inequality constraints. For each pair of variables V1 and V2 in FDVars, all_different(FDVars)generates the constraint V1|#!=|V2.\n","body":"all_different(${1:FDVars})$0"},"sat:all_distinct/1":{"prefix":"all_distinct","description":"all_distinct(FDVars)\n This constraint is the same as all_different, but it maintains a higher level of consistency. For some problems, this constraint is faster and requires fewer backtracks than all_different, and, for some other problems, this constraint is slower due to the overhead of consistency checking.\n","body":"all_distinct(${1:FDVars})$0"},"sat:alldifferent_except_0/1":{"prefix":"alldifferent_except_0","description":"alldifferent_except_0(Xs)","body":"alldifferent_except_0(${1:Xs})$0"},"sat:all_different_except_0/1":{"prefix":"all_different_except_0","description":"all_different_except_0(FDVars)\n This constraint is true if all non-zero values in FDVars are different.\n","body":"all_different_except_0(${1:Xs})$0"},"sat:element/3":{"prefix":"element","description":"element(I, List, V)\n This constraint is true if the Ith element of List is V, where I and V are integer-domain variables, and List is a list of integer-domain variables.\n","body":"element(${1:I}, ${2:FDVars}, ${3:V})$0"},"sat:fd_disjoint/2":{"prefix":"fd_disjoint","description":"fd_disjoint(FDVar1, FDVar2)\n This predicate is true if FDVar1's domain and FDVar2's domain are disjoint.\n","body":"fd_disjoint(${1:DVar1}, ${2:DVar2})$0"},"sat:count/4":{"prefix":"count","description":"count(V, FDVars, Rel, N)\n In this constraint, V and N are integer-domain variables, FDVars is a list of integer-domain variables, and Rel is an arithmetic constraint operator (|#=|,|#!=|, |#>|, |#>=|, |#<|, |#=<|, or |#<=|). Let Count be the number of elements in FDVars that are equal to V. The constraint is true iff Count Rel N is true. This constraint can be defined as follows:\n","body":"count(${1:V}, ${2:FDVars}, ${3:Rel}, ${4:N})$0"},"sat:reified_bool_vars/3":{"prefix":"reified_bool_vars","description":"reified_bool_vars([E|List],V,Bs)","body":"reified_bool_vars(${1:[E|List]}, ${2:V}, ${3:Bs})$0"},"sat:count_aux/3":{"prefix":"count_aux","description":"count_aux(Bs,'#<=',N)","body":"count_aux(${1:Bs}, ${2:'#<='}, ${3:N})$0"},"sat:count/3":{"prefix":"count","description":"count(V,FDVars,N)","body":"count(${1:V}, ${2:FDVars}, ${3:N})$0"},"sat:cumulative/4":{"prefix":"cumulative","description":"cumulative(Starts, Durations, Resources, Limit)\n This constraint is useful for describing and solving scheduling problems. The arguments Starts, Durations, and Resources are lists of integer-domain variables of the same length, and Limit is an integer-domain variable. Let Starts be [S_1 , S_2 , ..., S_n ], Durations be [D_1 , D_2 , ..., D_n ], and Resources be [R_1 , R_2 , ..., R_n ]. For each job i, S_i represents the start time, D_i represents the duration, and R_i represents the units of resources needed. Limit is the limit on the units of resources available at any time. This constraint ensures that the limit cannot be exceeded at any time.\n","body":"cumulative(${1:Starts}, ${2:Durations}, ${3:Resources}, ${4:Limit})$0"},"sat:diffn/1":{"prefix":"diffn","description":"diffn(RectangleList)\n This constraint ensures that no two rectangles in RectangleList overlap with each other. A rectangle in an n-dimensional space is represented by a list of 2 n elements [X_1 , X_2 , ..., X_n , S_1 , S_2 , ..., S_n ], where X_i is the starting coordinate of the edge in the ith dimension, and S_i is the size of the edge.\n","body":"diffn(${1:RectangleList})$0"},"sat:disjunctive_tasks/1":{"prefix":"disjunctive_tasks","description":"disjunctive_tasks(Tasks)\n Tasks is a list of terms. Each term has the form disj_tasks(S_1 ,D_1 ,S_2 ,D_2 ), where S_1 and S_2 are two integer-domain variables, and D_1 and D_2 are two positive integers. This constraint is equivalent to posting the disjunctive constraint S_1 +D_1 |#=<| S_2 |#\\/| S_2 +D_2 |#=<| S_1 for each term disj_tasks(S_1 ,D_1 ,S_2 ,D_2 ) in Tasks; however the constraint may be more efficient, because it converts the disjunctive tasks into global constraints. This constraint is only accepted by cp.\n","body":"disjunctive_tasks(${1:Tasks})$0"},"sat:disjunctive_tasks_aux/1":{"prefix":"disjunctive_tasks_aux","description":"disjunctive_tasks_aux(Tasks)","body":"disjunctive_tasks_aux(${1:Tasks})$0"},"sat:disjunctive_tasks_aux/4":{"prefix":"disjunctive_tasks_aux","description":"disjunctive_tasks_aux([disj_tasks(S1,D1,S2,D2)|Tasks])","body":"disjunctive_tasks_aux(${1:[disj_tasks(S1}, ${2:D1}, ${3:S2}, ${4:D2})$0"},"sat:assignment/2":{"prefix":"assignment","description":"assignment(FDVars1, FDVars2)\n This constraint ensures that FDVars2 is a /dual assignment/ of FDVars1, i.e., if the ith element of FDVars1 is j, then the jth element of FDVars2 is i. The constraint can be defined as:\n","body":"assignment(${1:FDVars1}, ${2:FDVars2})$0"},"sat:solve/1":{"prefix":"solve","description":"solve(Vars)\n This predicate is the same as solve([], Vars).\n","body":"solve(${1:Vars})$0"},"sat:solve/2":{"prefix":"solve","description":"solve(Options, Vars)\n This predicate calls the imported solver to label the variables Vars with values, where Options is a list of options for the solver. The options will be detailed below. For cp and sat, this predicate can backtrack in order to find multiple solutions. However, for mip, this call cannot backtrack. The cp module allows incremental labeling of variables, and some variables that occur in constraints but are not passed to solve may remain uninstantiated after a call to solve. The user is responsible for having all the variables that need to be instantiated passed to solve. In constrast, the sat module does not support incremental labeling of variables; once a call to solve succeeds, all the variables in constraints, whether they are passed to solve or not, will be instantiated when solve succeeds.\n","body":"solve(${1:Options}, ${2:Vars})$0"},"sat:solve_all/1":{"prefix":"solve_all","description":"solve_all(Vars)","body":"solve_all(${1:Vars})$0"},"sat:solve_all/2":{"prefix":"solve_all","description":"solve_all(Options, Vars) = Solutions\n This function returns all the solutions that satisfy the constraints.^2 <#note10>* solve_all(Vars) = Solutions: This function is the same as solve_all([],Vars).\n","body":"solve_all(${1:Options}, ${2:Vars})$0"},"sat:new_fd_var/0":{"prefix":"new_fd_var","description":"new_fd_var() = FDVar","body":"new_fd_var() = FDVar"},"sat:new_dvar/0":{"prefix":"new_dvar","description":"new_dvar() = FDVar\n This function creates a new domain variable with the default domain, which has the bounds-72057594037927935..72057594037927935 on 64-bit computers and-268435455..268435455 on 32-bit computers. \n","body":"new_dvar() = FDVar"},"sat:table_in/2":{"prefix":"table_in","description":"table_in(Vars,Tuples)","body":"table_in(${1:Vars}, ${2:Tuples})$0"},"sat:notin/2":{"prefix":"notin","description":"notin(Vars,Domain)","body":"notin(${1:Vars}, ${2:Domain})$0"},"sat:table_notin/2":{"prefix":"table_notin","description":"table_notin(Vars,Tuples)","body":"table_notin(${1:Vars}, ${2:Tuples})$0"},"sat:fd_dom/1":{"prefix":"fd_dom","description":"fd_dom(FDVar) = List\n This function returns the domain of FDVar as a list, where FDVar is an integer-domain variable. If FDVar is an integer, then the returned list contains the integer itself.\n","body":"fd_dom(${1:FDVar})$0"},"sat:fd_false/2":{"prefix":"fd_false","description":"fd_false(FDVar, Elm)\n This predicate is true if the integer Elm is not an element in the domain of FDVar.\n","body":"fd_false(${1:FDVar}, ${2:Elm})$0"},"sat:fd_max/1":{"prefix":"fd_max","description":"fd_max(FDVar) = Max\n This function returns the upper bound of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_max(${1:FDVar})$0"},"sat:fd_min/1":{"prefix":"fd_min","description":"fd_min(FDVar) = Min\n This function returns the lower bound of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_min(${1:FDVar})$0"},"sat:fd_min_max/3":{"prefix":"fd_min_max","description":"fd_min_max(FDVar, Min, Max)\n This predicate binds Min to the lower bound of the domain of FDVar, and binds Max to the upper bound of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_min_max(${1:FDVar}, ${2:Min}, ${3:Max})$0"},"sat:fd_next/2":{"prefix":"fd_next","description":"fd_next(FDVar, Elm) = NextElm\n This function returns the next element of Elm in FDVar's domain. It throws an exception if Elm has no next element in FDVar's domain.\n","body":"fd_next(${1:FDVar}, ${2:Elm})$0"},"sat:fd_prev/2":{"prefix":"fd_prev","description":"fd_prev(FDVar, Elm) = PrevElm\n This function returns the previous element of Elm in FDVar's domain. It throws an exception if Elm has no previous element in FDVar's domain.\n","body":"fd_prev(${1:FDVar}, ${2:Elm})$0"},"sat:fd_size/1":{"prefix":"fd_size","description":"fd_size(FDVar) = Size\n This function returns the size of the domain of FDVar, where FDVar is an integer-domain variable.\n","body":"fd_size(${1:FDVar})$0"},"sat:fd_true/2":{"prefix":"fd_true","description":"fd_true(FDVar, Elm)\n This predicate is true if the integer Elm is an element in the domain of FDVar.\n","body":"fd_true(${1:FDVar}, ${2:Elm})$0"},"sat:fd_vector_min_max/2":{"prefix":"fd_vector_min_max","description":"fd_vector_min_max(Min,Max)\n When the arguments are integers, this predicate specifies the range of bit vectors; when the arguments are variables, this predicate binds them to the current bounds of the range. The default range is -3200..3200. \n","body":"fd_vector_min_max(${1:Min}, ${2:Max})$0"},"sat:circuit/1":{"prefix":"circuit","description":"circuit(FDVars)\n Let FDVars be a list of variables [X_1 ,X_2 ,...,X_N], where each X_i has the domain 1..N. A valuation X_1 =v_1 , X_2=v_2 , ..., X_n =v_n satisfies the constraint if 1->v_1 , 2->v_2 ,..., n->v_n forms a Hamiltonian cycle. This constraint ensures that each variable has a different value, and that the graph that is formed by the assignment does not contain any sub-cycles. For example, for the constraint\n","body":"circuit(${1:L})$0"},"sat:circuit_aux/1":{"prefix":"circuit_aux","description":"circuit_aux(A)","body":"circuit_aux(${1:A})$0"},"sat:global_cardinality/2":{"prefix":"global_cardinality","description":"global_cardinality(List, Pairs)\n Let List be a list of integer-domain variables [X_1 , ..., X_d ], and Pairs be a list of pairs [K_1 -V_1 , ..., K_n -V_n ], where each key K_i is a unique integer, and each V_i is an integer-domain variable. The constraint is true if every element of List is equal to some key, and, for each pair K_i -V_i , exactly V_i elements of List are equal to K_i . This constraint can be defined as follows:\n","body":"global_cardinality(${1:List}, ${2:Pairs})$0"},"sat:neqs/1":{"prefix":"neqs","description":"neqs(NeqList)\n NeqList is a list of inequality constraints of the form X |#!=| Y, where X and Y are integer-domain variables. This constraint is equivalent to the conjunction of the inequality constraints in NeqList, but it extracts all_distinctconstraints from the inequality constraints. This constraint is only accepted by cp.\n","body":"neqs(${1:Neqs})$0"},"sat:serialized/2":{"prefix":"serialized","description":"serialized(Starts, Durations)\n This constraint describes a set of non-overlapping tasks, where Starts and Durations are lists of integer-domain variables, and the lists have the same length. Let Os be a list of 1s that has the same length as Starts. This constraint is equivalent to cumulative(Starts,Durations,Os,1).\n","body":"serialized(${1:Starts}, ${2:Durations})$0"},"sat:and Xi/0":{"prefix":"and Xi","description":"and Xi","body":"and Xi"},"sat:subcircuit/1":{"prefix":"subcircuit","description":"subcircuit(FDVars)\n This constraint is the same as circuit(FDVars), except that not all of the vertices are required to be in the circuit. If the ith element of FDVars is i, then the vertex i is not part of the circuit. This constraint is only accepted by cp and sat.\n","body":"subcircuit(${1:L})$0"},"sat:subcircuit_aux/1":{"prefix":"subcircuit_aux","description":"subcircuit_aux(A)","body":"subcircuit_aux(${1:A})$0"},"sat:subcircuit_aux/2":{"prefix":"subcircuit_aux","description":"subcircuit_aux(L,A)","body":"subcircuit_aux(${1:L}, ${2:A})$0"},"sat:regular/6":{"prefix":"regular","description":"regular(L, Q, S, M, Q0, F)\n Given a finite automaton (DFA or NFA) of Q states numbered 1, 2, ..., Q with input 1..S, transition matrix M, initial state Q0 (1 ? Q0 ? Q), and a list of accepting states F, this constraint is true if the list L is accepted by the automaton. The transition matrix M represents a mapping from 1..Q 1..S to 0..Q, where 0 denotes the error state. For a DFA, every entry in M is an integer, and for an NFA, entries can be a list of integers.\n","body":"regular(${1:L}, ${2:_Q}, ${3:_S}, ${4:_M}, ${5:_Q0}, ${6:_Fs})$0"},"sat:regular_aux/6":{"prefix":"regular_aux","description":"regular_aux(W, Q, S, M, Q0, Fs)","body":"regular_aux(${1:W}, ${2:Q}, ${3:S}, ${4:M}, ${5:Q0}, ${6:Fs})$0"},"sat:lex_le/2":{"prefix":"lex_le","description":"lex_le(L_1 ,L_2 )\n The sequence (an array or a list) L_1 is lexicographically less than or equal to L_2 .\n","body":"lex_le(${1:L1}, ${2:L2})$0"},"sat:lex_lt/2":{"prefix":"lex_lt","description":"lex_lt(L_1 ,L_2 )\n The sequence (an array or a list) L_1 is lexicographically less than L_2 .\n","body":"lex_lt(${1:L1}, ${2:L2})$0"},"sat:check_args_lex/4":{"prefix":"check_args_lex","description":"check_args_lex(L1,L2,L11,L22)","body":"check_args_lex(${1:L1}, ${2:L2}, ${3:L11}, ${4:L22})$0"},"sat:lex_le_aux/2":{"prefix":"lex_le_aux","description":"lex_le_aux(L1,L2)","body":"lex_le_aux(${1:L1}, ${2:L2})$0"},"sat:lex_le_aux/4":{"prefix":"lex_le_aux","description":"lex_le_aux([X1,X2],[Y1,Y2|_])","body":"lex_le_aux(${1:[X1}, ${2:X2]}, ${3:[Y1}, ${4:Y2|_]})$0"},"sat:lex_lt_aux/2":{"prefix":"lex_lt_aux","description":"lex_lt_aux(L1,L2)","body":"lex_lt_aux(${1:L1}, ${2:L2})$0"},"sat:lex_lt_aux/4":{"prefix":"lex_lt_aux","description":"lex_lt_aux([X1,X2],[Y1,Y2|_])","body":"lex_lt_aux(${1:[X1}, ${2:X2]}, ${3:[Y1}, ${4:Y2|_]})$0"},"sat:nvalue/2":{"prefix":"nvalue","description":"nvalue(N,List)\n The number of distinct values in List is N, where List is a list of integer-domain variables.\n","body":"nvalue(${1:N}, ${2:L})$0"},"sat:matrix_element/4":{"prefix":"matrix_element","description":"matrix_element(Matrix,I,J,V)\n This constraint is true if the entry at <I,J> in Matrix is V, where I, J, and V are integer-domain variables, and Matrix is an two-dimensional array of integer-domain variables.\n","body":"matrix_element(${1:M}, ${2:I}, ${3:J}, ${4:MIJ})$0"},"sat:scalar_product/3":{"prefix":"scalar_product","description":"scalar_product(A,X,Product)\n The scalar product of A and X is Product, where A and X are lists or arrays of integer-domain variables, and Product is an integer-domain variable. A and X must have the same length.\n","body":"scalar_product(${1:A}, ${2:X}, ${3:Product})$0"},"sat:scalar_product/4":{"prefix":"scalar_product","description":"scalar_product(A,X,Rel,Product)\n The scalar product of A and X has the relation Rel with Product, where Rel is one of the following operators: |#=|, |#!=|, |#>=|, |#>|, |#=<| (|#<=|), and |#<|.\n","body":"scalar_product(${1:A}, ${2:X}, ${3:'#<'}, ${4:Product})$0"},"sat:exactly/3":{"prefix":"exactly","description":"exactly(N,L,V)\n: This constraint succeeds if there are exactly N elements in L that are equal to V, where N and V must be integer-domain variables, and L must be a list of integer-domain variables.\n","body":"exactly(${1:N}, ${2:X}, ${3:V})$0"},"sat:at_most/3":{"prefix":"at_most","description":"at_most(N,L,V)\nThis constraint succeeds if there are at most N elements in L that are equal to V, where N and V must be integer-domain variables, and L must be a list of integer-domain variables.\n","body":"at_most(${1:N}, ${2:X}, ${3:V})$0"},"sat:at_least/3":{"prefix":"at_least","description":"at_least(N,L,V)\n* at_most(N,L,V):* circuit(FDVars)* count(V,FDVars,Rel,N)* cumulative(Ss,Ds,Rs,Limit)* decreasing(L)* decreasing_strict(L)* diffn(RectangleList)* disjunctive_tasks(Tasks)(cp only)* element(I,List,V)* exactly(N,L,V):* fd_degree(FDVar) = Degree(cp only)* fd_disjoint(DVar1,DVar2)* fd_dom(FDVar) = List* fd_false(FDVar,Elm)* fd_max(FDVar) = Max* fd_min(FDVar) = Min* fd_min_max(FDVar,Min,Max)* fd_next(FDVar,Elm) = NextElm* fd_prev(FDVar,Elm) = PrevElm* fd_set_false(FDVar,Elm)(cp only)* fd_size(FDVar) = Size* fd_true(FDVar,Elm)* fd_vector_min_max(Min,Max)* global_cardinality(List,Pairs)* increasing(L)* increasing_strict(L)* indomain(Var)(nondet) (cp only)* indomain_down(Var)(nondet) (cp only)* lex_le(L_1 ,L_2 )* lex_lt(L_1 ,L_2 )* matrix_element(Matrix,I,J,V)* neqs(NeqList)(cp only)* new_dvar() = FDVar* new_fd_var() = FDVar* regular(X, Q, S, D, Q0, F)* scalar_product(A,X,Product)* scalar_product(A,X,Rel,Product)* serialized(Starts,Durations)* solve(Options,Vars)(nondet)* solve(Vars)(nondet)* solve_all(Options,Vars) = List* solve_all(Vars) = List* solve_suspended(cp only)* solve_suspended(Options)(cp only)* subcircuit(FDVars)* table_in(DVars,R)* table_notin(DVars,R)\n","body":"at_least(${1:N}, ${2:X}, ${3:V})$0"},"sat:increasing/1":{"prefix":"increasing","description":"increasing(L)\n The sequence (an array or a list) L is in(non-strictly) increasing order.\n","body":"increasing(${1:FDVars})$0"},"sat:increasing_list/1":{"prefix":"increasing_list","description":"increasing_list([X|T@[Y|_]])","body":"increasing_list(${1:[X|T@[Y|_]]})$0"},"sat:increasing_strict/1":{"prefix":"increasing_strict","description":"increasing_strict(L)\n The sequence (an array or a list) L is in strictly increasing order.\n","body":"increasing_strict(${1:FDVars})$0"},"sat:increasing_strict_list/1":{"prefix":"increasing_strict_list","description":"increasing_strict_list([X|T@[Y|_]])","body":"increasing_strict_list(${1:[X|T@[Y|_]]})$0"},"sat:decreasing/1":{"prefix":"decreasing","description":"decreasing(L)\n The sequence (an array or a list) L is in(non-strictly) decreasing order.\n","body":"decreasing(${1:FDVars})$0"},"sat:decreasing_list/1":{"prefix":"decreasing_list","description":"decreasing_list([X|T@[Y|_]])","body":"decreasing_list(${1:[X|T@[Y|_]]})$0"},"sat:decreasing_strict/1":{"prefix":"decreasing_strict","description":"decreasing_strict(L)\n The sequence (an array or a list) L is in strictly decreasing order.\n","body":"decreasing_strict(${1:FDVars})$0"},"sat:decreasing_strict_list/1":{"prefix":"decreasing_strict_list","description":"decreasing_strict_list([X|T@[Y|_]])","body":"decreasing_strict_list(${1:[X|T@[Y|_]]})$0"},"sys:abort/0":{"prefix":"abort","description":"abort\n This predicate terminates the current program. This can be used in all three execution modes. \n","body":"abort"},"sys:cl/1":{"prefix":"cl","description":"cl(FileName)\n This predicate compiles and loads the source file named FileName.pi. Note that the extension .pi does not need to be given. The system also compiles and loads all of the module files that are either directly imported or indirectly imported by the source file. The system searches for such dependent files in the directory in which FileName.pi resides or the directories that are stored in the environment variable PICATPATH.\n","body":"cl(${1:File})$0"},"sys:cl_facts/1":{"prefix":"cl_facts","description":"cl_facts(Facts)\n This predicate compiles and loads facts into the system. The argument Facts is a list of ground facts.\n","body":"cl_facts(${1:Facts})$0"},"sys:cl_facts/2":{"prefix":"cl_facts","description":"cl_facts(Facts, IndexInfo)\n This predicate compiles and loads facts into the system. The argument Facts is a list of ground facts. The argument IndexInfo is a list of indexing information in the form p(M_1 , M_2 , ..., M_n ). Each M_i can either be +, which indicates that the argument is input, or -, which indicates that the argument is output.\n","body":"cl_facts(${1:Facts}, ${2:IndexInfo})$0"},"sys:cl_facts_table/1":{"prefix":"cl_facts_table","description":"cl_facts_table(Facts)\n This predicate is the same as cl_facts/1, except that the facts are all tabled.\n","body":"cl_facts_table(${1:Facts})$0"},"sys:cl_facts_table/2":{"prefix":"cl_facts_table","description":"cl_facts_table(Facts, IndexInfo)\n This predicate is the same as cl_facts/2, except that the facts are all tabled. \n","body":"cl_facts_table(${1:Facts}, ${2:IndexInfo})$0"},"sys:command/1":{"prefix":"command","description":"command(String) = Int\n This function sends the command String to the OS and returns the status that is returned from the OS. \n","body":"command(${1:String})$0"},"sys:compile/1":{"prefix":"compile","description":"compile(FileName)\n This predicate compiles the file FileName.pi and all of its dependent files without loading the generated byte-code files. The destination directory for the byte-code file is the same as the source file's directory. If the Picat interpreter does not have permission to write into the directory in which a source file resides, then this built-in throws an exception. If FileName.pi imports modules, then these module files are also compiled. The system searches for these module files in the directory in which FileName.pi resides or the directories that are stored in the environment variable PICATPATH.\n","body":"compile(${1:File})$0"},"sys:compile_bp/1":{"prefix":"compile_bp","description":"compile_bp(FileName)\n This predicate translates the Picat file FileName.pi into a B-Prolog file FileName.pl. If the file is dependent on other Picat files, then those files are compiled using compile/1. The destination directory for the B-Prolog file is the same as the source file's directory. If the Picat interpreter does not have permission to write into the directory in which a source file resides, then this built-in throws an exception.\n","body":"compile_bp(${1:File})$0"},"sys:debug/0":{"prefix":"debug","description":"debug\n This predicate switches the execution mode to trace mode.\n","body":"debug"},"sys:exit/0":{"prefix":"exit","description":"exit","body":"exit"},"sys:garbage_collect/0":{"prefix":"garbage_collect","description":"garbage_collect\n This predicate starts the garbage collector.\n","body":"garbage_collect"},"sys:garbage_collect/1":{"prefix":"garbage_collect","description":"garbage_collect(Size)\n This predicate calls the garbage collector. If there are less than Size words on the control stack and heap after garbage collection, then it invokes the memory manager to expand the stack and heap so that there are Size words on the control stack and heap. \n","body":"garbage_collect(${1:Size})$0"},"sys:halt/0":{"prefix":"halt","description":"halt","body":"halt"},"sys:help/0":{"prefix":"help","description":"help\n This predicate displays the usages of some of the commands that the system accepts.\n","body":"help"},"sys:initialize_table/0":{"prefix":"initialize_table","description":"initialize_table\n This predicate initializes the table area. \n","body":"initialize_table"},"sys:load/1":{"prefix":"load","description":"load(FileName)\n This predicate loads the byte-code file FileName.qi and all of its dependent byte-code files into the system for execution. For FileName, the system searches for a byte-code file in the directory specified by FileName or the directories that are stored in the environment variable PICATPATH. For the dependent file names, the system searches for a byte-code file in the directory in which FileName.qi resides or the directories that are stored in the environment variable PICATPATH. If the byte-code file FileName.qi does not exist, but the source file FileName.pi exists, then this built-in compiles the source file and loads the byte codes without creating a qi file. Note that, for the dependent files, if the byte-code file does not exist, but the source file exists, then the source file will be compiled.\n","body":"load(${1:File})$0"},"sys:loaded_modules/0":{"prefix":"loaded_modules","description":"loaded_modules() = List\n This function returns a list of the modules that are currently loaded in the Picat system. This list includes library modules and user-defined modules. By default, this function returns [basic,sys,io,math].\n","body":"loaded_modules()"},"sys:nodebug/0":{"prefix":"nodebug","description":"nodebug\n This predicate switches the execution mode to non-trace mode.\n","body":"nodebug"},"sys:nospy/0":{"prefix":"nospy","description":"nospy\n This predicate removes all spy points, and switches the execution mode to non-trace mode.\n","body":"nospy"},"sys:notrace/0":{"prefix":"notrace","description":"notrace\n This predicate switches the execution mode to non-trace mode.\n","body":"notrace"},"sys:picat_path/0":{"prefix":"picat_path","description":"picat_path() = Path\n This function returns the directories that are stored in the environment variable PICATPATH. If the environment variable PICATPATH does not exist, then this function throws an error.\n","body":"picat_path()"},"sys:spy/1":{"prefix":"spy","description":"spy(Point)\n This predicate places a spy point on Point, which is a function or a predicate, optionally followed by an arity. The creation of a spy point switches the Picat system to spy mode.\n","body":"spy(${1:Point})$0"},"sys:statistics/0":{"prefix":"statistics","description":"statistics\n This predicate displays the number of bytes that are allocated to each data area, and the number of bytes that are already in use.\n","body":"statistics"},"sys:statistics/2":{"prefix":"statistics","description":"statistics(Key, Value)\n The statistics concerning Key are Value. This predicate gives multiple solutions upon backtracking. Keys include runtime, program, heap, control, trail, table, gc, backtracks, and gc_time. The values for most of the keys are lists of two elements. For the key runtime, the first element denotes the amount of time in milliseconds that has elapsed since Picat started, and the second element denotes the amount of time that has elapsed since the previous call to statistics/2was executed. For the key gc, the number indicates the number of times that the garbage collectorhas been invoked. For the key backtracks, the number indicates the number of backtracks that have been done during the labeling of finite domain variables since Picat was started. For all other keys, the first element denotes the size of memory in use, and the second element denotes the size of memory that is still available in the corresponding data area.\n","body":"statistics(${1:Name}, ${2:Val})$0"},"sys:statistics_all/0":{"prefix":"statistics_all","description":"statistics_all() = List\n This function returns a list of lists that are in the form [Key, Value]. The list contains all of the keys that statistics/2can display, together with their corresponding values. \n","body":"statistics_all()"},"sys:time/1":{"prefix":"time","description":"time(Goal)\n This predicate calls Goal, and reports the number of seconds of CPU time that were consumed by the execution.\n","body":"time(${1:Goal})$0"},"sys:time2/1":{"prefix":"time2","description":"time2(Goal)\n This predicate calls Goal, and reports the number of seconds of CPU time that were consumed by the execution, and the number of backtracks that have been performed in labeling finite-domain variables during the execution of Goal.\n","body":"time2(${1:Goal})$0"},"sys:time_out/3":{"prefix":"time_out","description":"time_out(Goal, Limit, Result)\n This predicate is logically equivalent to once Goal, except that is imposes a time limit, in milliseconds, on the evaluation. If Goal is not finished when Limit expires, then the evaluation will be aborted, and Result will be unified with the atom time_out. If Goal succeeds within the time limit, then Result will be unified with the atom success. Note that time-out may be delayed or never occur because of the execution of an external C function. \n","body":"time_out(${1:Goal}, ${2:Limit}, ${3:Res})$0"},"sys:trace/0":{"prefix":"trace","description":"trace\n This predicate switches the execution mode to trace mode.\n","body":"trace"},"util:array_matrix_to_list/1":{"prefix":"array_matrix_to_list","description":"array_matrix_to_list(A) = List\n This function converts the array matrix A to a flat list, row by row. \n","body":"array_matrix_to_list(${1:A})$0"},"util:array_matrix_to_list_matrix/1":{"prefix":"array_matrix_to_list_matrix","description":"array_matrix_to_list_matrix(A) = List\n This function converts the array matrix A to a list matrix.\n","body":"array_matrix_to_list_matrix(${1:A})$0"},"util:list_matrix_to_array_matrix/1":{"prefix":"list_matrix_to_array_matrix","description":"list_matrix_to_array_matrix(L) = A","body":"list_matrix_to_array_matrix(${1:L})$0"},"util:join/1":{"prefix":"join","description":"join(Tokens) = String\n This function is the same as join(Tokens,\" \" ).\n","body":"join(${1:S})$0"},"util:join/2":{"prefix":"join","description":"join(Tokens,Separator) = String\n This function concatenates the tokens Tokens into a string, adding Separator, which is a string or an atom, between each two tokens.\n","body":"join(${1:S}, ${2:JoinStr})$0"},"util:join_aux/3":{"prefix":"join_aux","description":"join_aux([W|Str],JoinStr,Res) ","body":"join_aux(${1:[W|Str]}, ${2:JoinStr}, ${3:Res})$0"},"util:replace/3":{"prefix":"replace","description":"replace(Term,Old,New) = NewTerm\n This function returns a copy of Term, replacing all of the occurrences of Old in Term by New.\n","body":"replace(${1:T}, ${2:_Old}, ${3:_New})$0"},"util:replace_at/3":{"prefix":"replace_at","description":"replace_at(Term,Index,New) = NewTerm\n This function returns a copy of Term, replacing the argument at Index by New. Term must be a compound term.\n","body":"replace_at(${1:Struct}, ${2:I}, ${3:NewVal})$0"},"util:replace_list_at/5":{"prefix":"replace_list_at","description":"replace_list_at(_,_,_,_,ErrorFlag)","body":"replace_list_at(${1:_}, ${2:_}, ${3:_}, ${4:_}, ${5:ErrorFlag})$0"},"util:find/4":{"prefix":"find","description":"find(String,SubString,From,To)\n This predicate searches for an occurrence of SubString in String, and binds From to the starting index and To to the ending index. On backtracking, this predicate searches for the next occurrence of SubString.\n","body":"find(${1:String}, ${2:SubString}, ${3:From}, ${4:To})$0"},"util:find_ignore_case/4":{"prefix":"find_ignore_case","description":"find_ignore_case(String,SubString,From,To)\n This predicate is the same as find(String,SubString,From,To), except that it is case insensitive.\n","body":"find_ignore_case(${1:String}, ${2:SubString}, ${3:From}, ${4:To})$0"},"util:find_first_of/2":{"prefix":"find_first_of","description":"find_first_of(Term,Pattern) = Index\n This function returns the first index at which the argument unifies with Pattern. If there is no argument that unifies with Pattern, then this function returns -1. Term must be either a list or a structure.\n","body":"find_first_of(${1:Struct}, ${2:_Pattern})$0"},"util:find_list_first_of/4":{"prefix":"find_list_first_of","description":"find_list_first_of(_L,_Pattern,CurIndex,Index)","body":"find_list_first_of(${1:_L}, ${2:_Pattern}, ${3:CurIndex}, ${4:Index})$0"},"util:find_struct_first_of/5":{"prefix":"find_struct_first_of","description":"find_struct_first_of(_,_,CurIndex,_Arity,Index) => Index","body":"find_struct_first_of(${1:_}, ${2:_}, ${3:CurIndex}, ${4:_Arity}, ${5:Index})$0"},"util:find_last_of/2":{"prefix":"find_last_of","description":"find_last_of(Term,Pattern) = Index\n This function returns the last index at which the argument unifies with Pattern. If there is no argument that unifies with Pattern, then this function returns -1. Term must be either a list or a structure.\n","body":"find_last_of(${1:Struct}, ${2:_})$0"},"util:find_list_last_of/5":{"prefix":"find_list_last_of","description":"find_list_last_of([_|L],Pattern,CurIndex,_Index0,Index)","body":"find_list_last_of(${1:[_|L]}, ${2:Pattern}, ${3:CurIndex}, ${4:_Index0}, ${5:Index})$0"},"util:find_struct_last_of/4":{"prefix":"find_struct_last_of","description":"find_struct_last_of(_,_,CurIndex,Index) => Index","body":"find_struct_last_of(${1:_}, ${2:_}, ${3:CurIndex}, ${4:Index})$0"},"util:matrix_multi/2":{"prefix":"matrix_multi","description":"matrix_multi(A,B)\n This function returns the product of matrices A and B. Both A and B must be array matrices.\n","body":"matrix_multi(${1:A}, ${2:B})$0"},"util:permutation/2":{"prefix":"permutation","description":"permutation(List,P)\n This predicate generates a permutation P of List. This predicate is non-deterministic. On backtracking, it generates the next permutation.\n","body":"permutation(${1:Xs}, ${2:Ys})$0"},"util:permutations/1":{"prefix":"permutations","description":"permutations(List) = Ps\n This function returns all the permutations of List.\n","body":"permutations(${1:[H|T]})$0"},"util:nextto/3":{"prefix":"nextto","description":"nextto(E1,E2,List)\n This predicate is true if E1 follows E2 in List. This predicate is non-deterministic. \n","body":"nextto(${1:X}, ${2:Y}, ${3:List})$0"},"util:power_set/1":{"prefix":"power_set","description":"power_set([H|T]) = P1++P2","body":"power_set(${1:[H|T]})$0"},"util:split/1":{"prefix":"split","description":"split(String) = Tokens\n This function is the same as split(String,|\"\\t\\n\\r\")|, which uses white spaces as split characters.\n","body":"split(${1:Str})$0"},"util:split/2":{"prefix":"split","description":"split(String,Separators) = Tokens\n This function splits String into a list of tokens, using characters in the string Separators as split characters. Recall that a string is a list of characters. A token is a string, so the return value is a list of lists of characters.\n","body":"split(${1:Str}, ${2:Seperators})$0"},"util:lstrip/1":{"prefix":"lstrip","description":"lstrip(List) = List\n This function is the same as lstrip(List,|\"\\t\\n\\r\")|.\n","body":"lstrip(${1:L})$0"},"util:lstrip/2":{"prefix":"lstrip","description":"lstrip(List,Elms) = List\n This function returns a copy of List with leading elements in Elms removed.\n","body":"lstrip(${1:L}, ${2:_Elms})$0"},"util:rstrip/1":{"prefix":"rstrip","description":"rstrip(List) = List\n This function is the same as rstrip(List,|\"\\t\\n\\r\")|.\n","body":"rstrip(${1:L})$0"},"util:rstrip/2":{"prefix":"rstrip","description":"rstrip(List,Elms) = List\n This function returns a copy of List with trailing elements in Elms removed.\n","body":"rstrip(${1:L}, ${2:Elms})$0"},"util:strip/1":{"prefix":"strip","description":"strip(List) = List\n This function is the same as strip(List,|\"\\t\\n\\r\")|.\n","body":"strip(${1:L})$0"},"util:strip/2":{"prefix":"strip","description":"strip(List,Elms) = List\n This function returns a copy of List with leading and trailing elements in Elms removed.\n","body":"strip(${1:L}, ${2:Elms})$0"},"util:transpose/1":{"prefix":"transpose","description":"transpose(A) = B\n This function returns the transpose of the matrix A. A can be an array matrix or a list matrix. If A is an array matrix, then the returned transpose is also an array. If A is a list matrix, then the returned transpose is also a list.\n","body":"transpose(${1:Matrix})$0"},"util:rows/1":{"prefix":"rows","description":"rows(A) = List\n This function returns the rows of the matrix A as a list.\n","body":"rows(${1:A})$0"},"util:columns/1":{"prefix":"columns","description":"columns(A) = List\n This function returns the columns of the matrix A as a list.\n","body":"columns(${1:A})$0"},"util:diagonal1/1":{"prefix":"diagonal1","description":"diagonal1(A) = List\n This function returns primary diagonal of the matrix A as a list.\n","body":"diagonal1(${1:A})$0"},"util:diagonal2/1":{"prefix":"diagonal2","description":"diagonal2(A) = List\n This function returns secondary diagonal of the matrix A as a list.\n","body":"diagonal2(${1:A})$0"},"util:take/2":{"prefix":"take","description":"take(List,K) = List\n This function returns the prefix of List of length K, or List itself if K is greater than the length of List. \n","body":"take(${1:L}, ${2:N})$0"},"util:take_aux/3":{"prefix":"take_aux","description":"take_aux(_List,_N,Taken) => Taken","body":"take_aux(${1:_List}, ${2:_N}, ${3:Taken})$0"},"util:drop/2":{"prefix":"drop","description":"drop(List,K) = List\n This function returns the suffix of List after the first K elements are dropped, or [] if K is greater than the length of List.\n","body":"drop(${1:L}, ${2:N})$0"},"util:drop_aux/3":{"prefix":"drop_aux","description":"drop_aux(L,_,Taken),list(L)","body":"drop_aux(${1:L}, ${2:_}, ${3:Taken})$0"},"util:chunks_of/2":{"prefix":"chunks_of","description":"chunks_of(List,K) = ListOfLists\n This function splits List into chunks, each of which has length K, and returns the list of the chunks. The last chunk may have less than K elements if the length of List is not a multiple of K.\n","body":"chunks_of(${1:L}, ${2:N})$0"},"util:chunks_of/5":{"prefix":"chunks_of","description":"chunks_of([X|Xs],Chunk,Count,N,Chunks)","body":"chunks_of(${1:[X|Xs]}, ${2:Chunk}, ${3:Count}, ${4:N}, ${5:Chunks})$0"}}
